import { html, svg, LitElement, css, unsafeCSS } from 'lit-element';
import { classMap } from 'lit-html/directives/class-map';
import AXAInputFile from '@axa-ch/input-file';
import { AddSvg, Attach_fileSvg, Delete_foreverSvg, ClearSvg } from '@axa-ch/materials/icons/material-design';
import '@skatejs/val';
import toBlob from 'blueimp-canvas-to-blob';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var fireCustomEvent = (function (eventName, detail, target) {
  var {
    bubbles = true,
    composed = true
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // note: the spec(https://dom.spec.whatwg.org/#dom-customevent-customevent),
  // allows 'eventName' to be an existing native event name (e.g. 'change'), which
  // is thereby endowed with the ability to carry custom data (in 'detail')
  var event = new CustomEvent(eventName, {
    detail,
    bubbles,
    composed
  });
  target.dispatchEvent(event);
});

var FileUploadGroupSvg = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="178" height="97" viewBox="0 0 178 97"><g data-name="Gruppe 24" transform="translate(-170 -186)"><g data-name="icon group" transform="translate(-1354 -560)"><image data-name="-e-images-icon" width="50" height="50" transform="translate(1589 746)" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAABHNCSVQICAgIfAhkiAAABVNJREFUaIHV2musHVUVB/DfLbUVhFrEGEko0VhAaYi1USMGqamRSERAjJo0akTNQkHAR03T2pbWPohGK9RK7PJBMEa0ool8wFeiJWqCj4CBiI0ENUbjozWW1gYLleuHPYccbs6ZMzP33Hv1n0wmc/baa681/9l7r73WmZicnDQMmbkAV+NiLBwqODc4jh9hV0QcmRjmSGaegLtwEf6Ov8yaic1wGs7A/bhgfo3gWxQnduIjEfHELBjXCpl5HW7GtfNq5C7EJDb/LzoBEbELf8PKOkZOxOGIOFKnLDNPwVn4Nx6OiGNjs7QZ/oqFdY7UIjPPwCdxBZ5W/XwkMz+PTRFxdPo2NsfE5OSkzDwZb8KpfW2rcR4WT33LmXkWfqJMuG8oq8dCXI5VuBcrI+JfM+1AZv4Kh+Zn5pLKqDOHyJ6IY30dJ/BVLMJFEfHDPtnPZOb1uAmfwlUzYfwgzMMGLKkGfX7f9ZshfS7AS7FjihMgIm7GnbgyM585E0YPwnycg/0Rkf0NmfnYkD6vrO57a/TegUuxQvnsZhy95XeY0YPw5MSukTlc3Z/e2qKOqNtHhuG31f3CGple2/4O+juhiyPfwT+wNTNPndqYmefhvfhpRPx+mvY1Rut9JCKOZOY1+Bp+lpkf9dTld5sSEVw9TkNHoQsjIuLryj5zmjLpD+BP2I2DWBUR94/LyCbo5AhExO3KMr0a23EDLsG5EfHztvoyc0VXW+jwafUjIg7j9unogMxcjB9k5qsi4sEuOjozMmZ8AM/C5q4K5tyRzHw2Plw9vjkzX9JFz5w7gjU4GdfgcXysi5I5daRi4/24JyJuwZdwSWa+oq2uuWZkDZ6BddXzVuWAtr2torE4kpmLMrOVrsw8Hdfj7ojYBxHxZ+zBqsx8dRt942JkvZKsaIO1SlA5daXajqPY0UbZtB2p3uy12NSUlarPVdjXY6OHiDiAXTg/My9uasc4GFmHk/AizVnpsbFuSPsn8Ah2VCfSkZiWI5l5phLp3q1ExCNZqfq8D9+LiHsGyUTEIeWovBxvbGLLdBnZohy0PqRkVJqwsh4LjN7FP628nG1NPtnOjmTmOXg7vhUR9yqRby0rFRvvwneHsdFDlYG5UXk5q0fZMx1GtlT9N/YNPIqV9QqD6xuOcYuSgNucmbUBbidHqnjorfjylGh1KCuZuRTvxrcj4r4m40TEo8om+QJcWSfblZGtBsRFI1jZoBwbtrQc6wv4IzZWZY6BaO1IZp6P1+OLEfG7ASI9Vjb2ls6KjbdpwUYPEfGYcmhboub43IWRG5V4aGCU2sfKubis+nlDNVbTuTEVX8FDWJuZJw0SaBsfvRYrsTsi6go/PVZuyMxlCht7u57+IuI4NuG5uG6QTGNHqs9km5KY+/iIgXusLMfnqnE6nTP6sBcPYM2gVGwbRi7Dy7EzIg42kN+NQ0quuDMbPVTFpk1K5uaDU9sn9uzZs08pHSzvb6jS9S9WSg2HlVrdMiUyPd5w/EWYUFKyj3b04Sn2VjofwdKIOPhkWaGhgrPxy+pqigV4WTX4P/HrFn2bYAW+33to5EhE7Mc7x2zIWFE3R3qls2WzYUgXVGHL6ThWx8idSi3kjsxci0Gb32zjqPKZwilK1P0c3FXnyE68B0tx24yaNz18E58d6khEPJ6ZL8Q78Dpl8s4lLscvlPolPIH7IuLHjJjsEfEf3Fpdc4rMnMSDEXHToPa5zmuNDf8XjvQlIIb+lWmeEkacnZnPmxWruuGK6j60lDdfKe6/AQ9k5sOzYVVLnKAcCQ4ghwn1/sLxGiXJtniWjGuLP2B7RDw0TOC/1yOwaeG7LXcAAAAASUVORK5CYII="/><image data-name="-e-document_thicc" width="40" height="55" transform="translate(1524 776)" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAA3CAYAAAB+fggjAAAABHNCSVQICAgIfAhkiAAAAohJREFUaIHt2k2oVVUUwPHf876BNHHSpJE4cRSE0sxGBVKiROVAkhworKBo2khwGkhOBPEsMKWgTNAGigOnftDEQYOHaZERUWGBDUIQfe85uHcQ92O/d8559z4fnD+c0V6H/Wfftc5eZ587V1XVLpzCS9hkNiziQkR8slLgXFVVP2A7bg9unDZb8Aqe4quIOFwKnquq6gF+iohdM5CTmYEKj9GzguSmwfV0FnJDfI/f8EFmnpkUNKucG8cfeAs/41BmfpmZc8NB6ykoIu5hD37BQXw7LLmughAR9/Gm/kq+Z0hyftKNmXka+2rMtYjdEfFjE8nMfANXB5LnM/NARCyXVvAe7te4fsW/q/BZniD5O3bjDvbjYmb2Jq5gRJzAiVVMWJdbeITXMvMShgvjL2zDO/huouC0iIiFzDyHAwOJEq+WcvBFvG58IT3BlYh43FDy48w8iq2FsFPYWlrBs9hbGD+OTxv4gYh4iIeTxjPzCYUqxmf42/ikXsbJpnJ1KBXJTdychUSJdX9Qr0Qn2JZOsC2dYFuabnVryRKuRcTYTqi0k3yhXj/Yhov6LdYIJcHj+MeE/m2NOT1poLTVXcf1qejUYEMXyT68a/qnDT18ExHXxg2WcvAI3p6K0iibUVvwfeww/TRY1D8XGkupSB7p+sGVKRXJ52aXg+cj4ui4gVIO/qf//jpyoLPGLA/mGkspB4/h2DSM6rChc/AFzR4zdyPiQSur/1HKwa81K5IFvNxMZ5SS4Bn9N/+6W92d5jqjlIrkMi6v5WRNeO6LpBNsSyfYlk6wLZ1gWzrBtmwIwSXlrma96GFpHn9iZ2beMJv/LKyGHnZiYR4f6X922u75+cmXcBcfPgMvR7n+EM1ZuQAAAABJRU5ErkJggg=="/><image data-name="-e-check_list_thicc" width="40" height="55" transform="translate(1662 776)" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAA3CAYAAAB+fggjAAAABHNCSVQICAgIfAhkiAAABBFJREFUaIHd2luoVFUcx/GPeiyV6AK9lA9SVJAUoZhImkJRaaARGpahkcFfsvKhh+ilwKCCMEoEdf4VqVFYpEYRWXQhkS5YDxYamRRYlHhBwihvHXvYu7Dj3PbxnDnWD/bDHtaa+c6a//7utdaeQbVabSKW4wIM1pn8idci4oFWDQfVarWtuAxflh37O+fgKhzDSxExv1njQbVabQ++i4iJHYCTmYEaDmOIFpCDy+NYJ+B65DPswtzMfKFRo07VXL38jGnYiXmZuSYzB/VsNJCAImIHbsb3uBOv9oQcUECIiB8wVTGSM/WAHHBA/oG8HtsUkGv/hhwIwOP1XoyIn3AjvsEsrMvMIV2dJCvzCX7HpMxcj54Xxm5chFuxoeOAEbEtM1fh9hKiWcYNSA1GxH24BGOaHJ/ieK9GMDPHYmhEfH4KkAdwoMlnHKUXF0lm3oV3sKy3cFXScAQzczC2YEdE3FG+dj8WK4r8kTp9xmGeal/8q4jIyoAR0V1CzszMR3EUD2Mf5jT4eZ/G5ApwsC8zV0fE4UqAZeZhIxZhuOLmPj0idjZof6/CYVWyvRFcS8CI+DozF+MZ7MC0iNjdpP12PFYRsGla1kpZH9dhYjO4/kpbmulZb5nZhcERcaRfqE5IbzQzGluxqe9xTk7TEczMlfgiIp4vz8fjFYzCc3Xad2Gkk++vzbI/Ig5WBiwVMxWzMnMXjmA1zseyiHiwTrcNinqtkv2ZeWllzZQefApLsALDcBYej4gnGnR7H0MrAu49Fc0sz8wJmKsQ9EMRUWvSfimWVgRsmnau4vn4DRsj4s2+/PB20hIwIo5hYQdY6qbydCszh2Mt9kXEPX2P9O809WBmzsnMK044PxsfYgbO62c2tNbMEhzKzMk4hPcU+ypvY3adPs8qVmdV8iumRETdfaGGIxgR3XhLsYBZj49wpULU0yPiaJ1uw3t5NBR7qxpciNGYpBjBlc22zCJiQYv3q5ymNVgO+0xsVgi65X5eX6cdzezBtR1gqZvTYuujWXrjwaFYhUOnoweHKVQzB+f2Mxva9+BExf34PYxX6KeeB5eqPt3qEw++jo8xDi/jlvIe3TPDyqOKA890ih68XHEV/4EVEbGoyZcaMA9uUniwIVx/pR0P7sWUDrDUzf/Sg2fgRRxu9ZSoL9LKgzdk5qgTzkfgXYUHL+5nNrT24BocLD14uISboNj9nFGnz5N6Nx+8qdRa+4DlsvMDxQOWNxTOGqOQ9fQG2x4jcaFqC/cRimd21QDL3K3YS76mfIN1mN3I+hExrwJYW2m1Lj6ambcpZtRbIqLjq7t2PPgjru4AS92c9h78TwB264WwO5Ah6O7CLxibmZt15j8L7WQIxmJbl2JKtVzxx4rT5SfvxrdY8Bc073ZX5XREIgAAAABJRU5ErkJggg=="/></g><image data-name="-e-plus_black_thicc" width="30" height="30" transform="translate(245 253)" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABHNCSVQICAgIfAhkiAAAAdhJREFUSInt1r1qFWEQxvFf4hosFFT8KoQggiZl8ANBtNBCbexUFJs0g4WBXIAXkUbDmSYWXoBYWAgREUHUziYYC0FQtJFoMDHE5FjsHkgknJMNnso88DK7szvzH96XndmeZrOpjjJzN8ZwFVvxDLcjYqpOnp464MzsxSscxwLmsRMzGIiIr+vN1VunSpyvoG9xAHswUcFv1UlUF3y0sg8iYiYilpCV71A3wUVlF1f4ftXMsSHwP9MmeBPcNRWQmdtxAwMdihlq8+xkZo61ed7Ee2UP+FFkZj9e4GCNgr+tuJ6r7GC1OulOZp4pcLeCPla2v98dAucw2bqJiOnMPIf+DnG9uIKLGO9pNBqLyma/NyIW1lHxhpWZffiMXa3zXFKeQbe1pNzR5UK5xZfxMDMnrO7Da+knnlYDAmTmKeW0aqctuI79eFRgBMdwqVrr0TDuV9DDeLnOOPiEkSIiPmbmIG7iCHraBA3hrHL+trSjslN40ia2iWnl5zRbQETMYrxTqZk5WoHX0uuIGO2Uo6X/r2VugjfBf6s1QIoVvr6NgIvOr6zSu8pey8x7yl/b4cr3oZvgSbzBCeWUmVf26O9o1ElUa6sjYhkXlH16G/bhOU5HxJc6uf4A9Kx/mTgPCVgAAAAASUVORK5CYII="/></g></svg>';

var defineOnce = ((name, customElementClass) => {
  // normalize name since HTML tag names don't allow case distinction
  var lowerCaseName = name.toLowerCase(); // custom element not already registered?

  if (!window.customElements.get(lowerCaseName)) {
    // no, register it now
    window.customElements.define(lowerCaseName, customElementClass);
  } // return its name as a convenience


  return lowerCaseName;
});

var RESERVED_CHARACTER = '{'; // not allowed in HTML tags or their attributes ...
// and also not part of static template strings due to ${...} syntax!
// helper functions

var toKebabCase = dottedVersionString => "".concat(dottedVersionString).replace(/\./g, '-').replace(/[^A-Za-z0-9-]/g, '');

var versionedTag = (tagName, version) => "".concat(tagName, "-").concat(toKebabCase(version));

var extractDependencies = componentClass => {
  var {
    versions,
    tagName
  } = componentClass; // extract all dependencies...

  var dependencies = Object.keys(versions) // ... by comparing with master-component tag name
  .filter(name => name !== tagName) // ... and sorting longest-first (e.g. axa-button-link comes before axa-button)
  .sort((a, b) => b.length - a.length); // pair the list of dependency tag names with their versions

  return [dependencies, dependencies.map(_tagName => versions[_tagName])];
};

var oldTag = function oldTag(tagName) {
  var closing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var openingBracket = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '<';
  return "".concat(openingBracket).concat(closing).concat(tagName);
}; // How to make a new tag? It's tempting to just append the version info.
// However, we don't want to rewrite tags more than once: given axa-button-link in version 6.3.4
// and axa-button in version 5.0.9, we DONT'T WANT
// <axa-button-link =1> <axa-button-link-6-3-4 =2> <axa-button-5-0-9-link-6-3-4.
// So, the simplest solution replaces a rewritten tag in such a way that it does not START
// like any other tag, using a reserved character '{'. To continue with our example, we might have
// <axa-button-link =1> {axa-button-link-6-3-4. Then the erroneous rewriting step =2> can no longer match.
// Of course, in the end we need a bulk replacement of the '{'s by their original '<'s, which is simple.


var newTag = (tagName, aVersion, closing) => oldTag(versionedTag(tagName, aVersion), closing, RESERVED_CHARACTER); // Example: someStrings = ['<div><axa-dropdown .items="','" </axa-dropdown></div>']
//          aTagname = 'axa-dropdown', aVersion = '7.0.2'
//
// Rewritten as           ['<div><axa-dropdown-7-0-2 .items="','" </axa-dropdown-7-0-2></div>'].
//
// Note: this uses the split-join technique to perform global string substitution
// without needing the special-character escaping necessary for
// a reg-exp-based alternative (the latter is marginally faster, but our strings here are short)


var rewrite = (someStrings, aTagName, aVersion) => someStrings.map(string => string.split(oldTag(aTagName)).join(newTag(aTagName, aVersion)).split(oldTag(aTagName, '/')).join(newTag(aTagName, aVersion, '/'))); // ///
// API functions
// ///
// examples:
//           defineVersioned([AXADatepicker],  __ VERSION_INFO__); // main component
//           defineVersioned([AXADropdown],  __ VERSION_INFO__, this); // dependent component
//           defineVersioned([AXACheckbox], 'rsv'); // custom version


var defineVersioned = (dependencies, versionInfo, parentInstance) => {
  // set up
  var customVersion = typeof versionInfo === 'string' && versionInfo;
  var versionedTagName = ''; // process all dependant components that it lists...

  dependencies.forEach(dependency => {
    var componentClass = dependency instanceof HTMLElement ? dependency.constructor : dependency; // extract each dependant component's version

    var {
      tagName
    } = componentClass;
    var externalVersion = !customVersion && versionInfo[tagName]; // ordinary, non-POD versioning?

    if (externalVersion) {
      // yes, first time versioning/registration of this component, but its class
      // contains a PL-reserved 'versions' property?
      if (!window.customElements.get(tagName) && componentClass.versions) {
        // yes, this class is wrongly implemented - premature exit
        throw Error("'versions' is a reserved class property, but was found in ".concat(tagName, "'s class"));
      } // inject version info into component-defining class - this helps for live debugging


      componentClass.versions = externalVersion; // define its *unversioned*-tag variant first

      defineOnce(tagName, componentClass);
    } // extract each dependant component's version,


    var {
      versions
    } = componentClass; // If there is no version found, use the wrapping custom-element's version

    if (!versions && parentInstance) {
      // returns an array containing one object, which contains the tagname of the parent as key and its deployed version as value
      versions = versionInfo[parentInstance.constructor.tagName]; // extract the one item in the versions array and get only the version as string
      // eslint-disable-next-line prefer-destructuring

      versions[tagName] = Object.values(versions)[0];
    } // assembling a new, versioned name,


    var version = customVersion || versions[tagName];
    versionedTagName = versionedTag(tagName, version); // and redundantly defining
    //     versionedTagName |-> dependentComponentClass'
    // in parallel to the existing unversioned definition
    //     tagName |-> dependentComponentClass
    //
    // Note: the class expression formally creates a *new* dependentComponentClass' with identical behaviour,
    // which is needed to get around a bi-uniqueness constraint imposed by the
    // custom-elements registry, cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define
    // under section Exceptions:NotSupportedError)

    defineOnce(versionedTagName, class extends componentClass {});
  });
  return versionedTagName; // for convenience in single-component custom-versioned definitions
};

var versionedHtml = componentInstance => function (strings) {
  // derive class from instance
  var componentClass = componentInstance.constructor; // extract dependency info by looking at versions of component

  var [tagNames, versions] = extractDependencies(componentClass); // rewrite incoming array of static parts of template literals
  // in such a way that tags of dependent components are versioned:

  var newStrings = strings; // 1. rewriting proper, turning tags into versioned ones with funny initial brackets (see newTag(...) above)

  for (var i = 0, n = tagNames.length; i < n; i++) {
    newStrings = rewrite(newStrings, tagNames[i], versions[i]);
  } // 2. finish rewriting by converting funny initial brackets back to standard ones


  for (var _i = 0, _n = newStrings.length; _i < _n; _i++) {
    newStrings[_i] = newStrings[_i].split(RESERVED_CHARACTER).join('<');
  } // let lit-html see the rewritten static parts together with the
  // unchanged dynamic arg(ument)s


  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return html(newStrings, ...args);
};

var isDefined = value => !(value === undefined || value === null);
// (IE11 does not support new Map([iterable]), so we have to initialize the map
// with .set calls for each key)


var DEFAULT_VALUE_OF_TYPE = new Map();
[[String, ''], [Boolean, false], [Object, {}], [Array, []], [Number, 0], [Function, () => {}]].forEach(_ref => {
  var [key, value] = _ref;
  DEFAULT_VALUE_OF_TYPE.set(key, value);
});

var emptyFunction = () => {}; // convert *attribute* value


var convert = (value, type) => {
  if (type === Number) {
    return parseFloat(value);
  }

  if (type === Function) {
    // corner case: inline event handlers like onchange="alert(event)" cannot be reliably converted from string,
    // so just return an empty function s.t.  event-handler invocations in component code don't throw exceptions
    // (components are responsible for firing synthetic events on their root element instead to trigger expected
    // inline event handlers)
    return emptyFunction;
  }

  return type === Array || type === Object ? JSON.parse(value) : value;
};

var applyDefaults = ceInst => {
  var {
    constructor: {
      properties
    }
  } = ceInst; // get all properties of the custom element and loop over each key

  Object.keys(properties).forEach(property => {
    // extract default value and property type
    var propertyValue = properties[property];
    var {
      type,
      converter,
      defaultValue
    } = propertyValue;

    if (!type) {
      if (!converter) {
        throw new Error("<".concat(ceInst.nodeName, "> property \"").concat(property, "\" is missing a type!"));
      }

      return;
    } // respect property values defined before CE is constructed


    var value = ceInst[property];

    if (isDefined(value)) {
      return;
    } // Boolean attributes in HTML are true if present, false otherwise.
    // For all other types, get their value as string...


    value = type === Boolean ? ceInst.hasAttribute(property) : ceInst.getAttribute(property); // .. and if defined

    if (isDefined(value)) {
      // convert it
      ceInst[property] = convert(value, type);
      return;
    } // otherwise, apply default
    // make sure the set value() function is never triggered when defaultValue
    // is undefined otherwise the isControlled flag and firstTime flag are messed up in
    // some components containing controlledness. Writing undefined again on value counts as change


    if (defaultValue === undefined && 'defaultValue' in propertyValue) {
      return;
    } // component author explicitly specified a default value for this property?
    // (This allows *all* values as defaults, *including* undefined. The latter is
    // the proper default for 'value' properties in React's controlled-component mode.)
    // no, derive it from general per-type defaults


    ceInst[property] = 'defaultValue' in propertyValue // component author wants full control of their default value?
    ? defaultValue // yes, apply it
    : DEFAULT_VALUE_OF_TYPE.get(type);
  });
};

var styles = ".m-file-upload {\n  font-size: 16px;\n  letter-spacing: 0.02em;\n  line-height: 24px;\n  font-family: \"Source Sans Pro\", Arial, sans-serif;\n  color: #000;\n}\n.m-file-upload__dropzone {\n  background-color: #fff;\n  box-sizing: border-box;\n  padding: 30px 0;\n  height: 290px;\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: space-between;\n  align-items: center;\n  border: 2px dashed #999;\n}\n.m-file-upload__dropzone_dragover {\n  opacity: 0.25;\n}\n.m-file-upload__dropzone_dragover * {\n  pointer-events: none;\n}\n.m-file-upload__dropzone-file-overview {\n  padding: 22px 7px 0px 22px;\n  flex-flow: row wrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  align-content: flex-start;\n  overflow-y: scroll;\n  border-style: solid;\n}\n.m-file-upload__or {\n  text-transform: uppercase;\n  font-weight: bold;\n  color: #ec4d33;\n  margin: 0;\n}\n.m-file-upload__information {\n  margin: 0;\n}\n.m-file-upload__input {\n  fill: currentColor;\n}\n.m-file-upload__img-figure {\n  position: relative;\n  margin: 0;\n  margin-right: 15px;\n  margin-bottom: 20px;\n}\n.m-file-upload__icon-hover-area {\n  position: relative;\n  height: 80px;\n  width: 120px;\n}\n.m-file-upload__icon-hover-area:hover {\n  cursor: pointer;\n}\n.m-file-upload__icon-hover-area:hover .m-file-upload__img-element {\n  opacity: 0.25;\n}\n.m-file-upload__icon-hover-area:hover .m-file-upload__file-element {\n  opacity: 0.25;\n}\n.m-file-upload__icon-hover-area:hover .m-file-upload__icon-delete {\n  display: block;\n}\n.m-file-upload__icon-hover-area:hover .m-file-upload__icon-error {\n  display: none;\n}\n.m-file-upload__img-element {\n  width: 100%;\n  height: 100%;\n}\n.m-file-upload__file-element {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  margin-right: -50%;\n  transform: translate(-50%, -50%);\n}\n.m-file-upload__file-element svg {\n  height: 36px;\n  width: 36px;\n}\n.m-file-upload__icon-layer {\n  position: absolute;\n  height: 36px;\n  top: 50%;\n  left: 50%;\n  margin-right: -50%;\n  transform: translate(-50%, -50%);\n}\n.m-file-upload__icon-delete {\n  display: none;\n  color: #00008f;\n  fill: currentColor;\n}\n.m-file-upload__icon-delete svg {\n  height: 36px;\n  width: 36px;\n}\n.m-file-upload__icon-error {\n  color: #c91432;\n  fill: currentColor;\n}\n.m-file-upload__icon-error svg {\n  height: 36px;\n  width: 36px;\n}\n.m-file-upload__img-caption {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  min-height: 41px;\n  cursor: default;\n}\n.m-file-upload__filename, .m-file-upload__error {\n  display: inline-block;\n  width: 120px;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  text-align: center;\n}\n.m-file-upload__error {\n  font-size: 14px;\n  letter-spacing: 0.02em;\n  line-height: 17px;\n  font-family: \"Source Sans Pro\", Arial, sans-serif;\n  color: #c91432;\n}\n.m-file-upload__icon-hover-area:hover ~ .m-file-upload__img-caption .m-file-upload__filename,\n.m-file-upload__icon-hover-area:hover ~ .m-file-upload__img-caption .m-file-upload__error {\n  display: none;\n}\n.m-file-upload__icon-hover-area:hover ~ .m-file-upload__img-caption[data-status]:after {\n  content: attr(data-status);\n}\n.m-file-upload__icon-hover-area:hover ~ .m-file-upload__img-caption[data-status] {\n  color: #00008f;\n}\n.m-file-upload__add-more {\n  position: relative;\n  height: 80px;\n  width: 120px;\n  box-sizing: border-box;\n  cursor: pointer;\n  border: 2px dashed #999;\n  color: #999;\n}\n.m-file-upload__add-more .m-file-upload__icon-wrapper {\n  height: 100%;\n  width: 100%;\n  display: block;\n  position: relative;\n  fill: currentColor;\n}\n.m-file-upload__add-more .m-file-upload__icon-wrapper svg {\n  height: 36px;\n  width: 36px;\n}\n.m-file-upload__add-more .m-file-upload__img-caption {\n  width: 116px;\n  margin-top: 2px;\n  position: block;\n}\n.m-file-upload__error-wrapper {\n  color: #c91432;\n}";

var URL = window.URL || window.webkitURL;
var {
  FileReader
} = window;
var REGEXP_EXTENSION = /\.\w+$/;
var DEFAULTS = {
  maxWidth: 1024,
  maxHeight: 1024,
  minWidth: 0,
  minHeight: 0,
  width: undefined,
  height: undefined,
  quality: 0.6,
  mimeType: 'image/jpeg',
  convertSize: 5000000,
  success: null,
  error: null
};

var isImageType = value => /^image\/.+$/.test(value);

var imageTypeToExtension = function imageTypeToExtension(value) {
  var includeDot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var extension = isImageType(value) ? value.substr(6) : '';

  if (extension === 'jpeg') {
    extension = 'jpg';
  }

  if (extension && includeDot) {
    extension = ".".concat(extension);
  }

  return extension;
};

var createImage = (url, file, image) => {
  var _image = image;
  return new Promise((resolve, reject) => {
    _image.onload = () => {
      resolve({
        width: _image.naturalWidth,
        height: _image.naturalHeight
      });
    };

    _image.onabort = reject;
    _image.onerror = reject;
    _image.alt = file.name;
    _image.src = url;
  });
};

var appendToCanvas = (width, height, _options, file, image) => new Promise(resolve => {
  var options = _options;
  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');
  var aspectRatio = width / height;
  var maxWidth = Math.max(options.maxWidth, 0) || Infinity;
  var maxHeight = Math.max(options.maxHeight, 0) || Infinity;
  var minWidth = Math.max(options.minWidth, 0) || 0;
  var minHeight = Math.max(options.minHeight, 0) || 0;
  var canvasWidth = width;
  var canvasHeight = height;

  if (maxWidth < Infinity && maxHeight < Infinity) {
    if (maxHeight * aspectRatio > maxWidth) {
      maxHeight = maxWidth / aspectRatio;
    } else {
      maxWidth = maxHeight * aspectRatio;
    }
  } else if (maxWidth < Infinity) {
    maxHeight = maxWidth / aspectRatio;
  } else if (maxHeight < Infinity) {
    maxWidth = maxHeight * aspectRatio;
  }

  if (minWidth > 0 && minHeight > 0) {
    if (minHeight * aspectRatio > minWidth) {
      minHeight = minWidth / aspectRatio;
    } else {
      minWidth = minHeight * aspectRatio;
    }
  } else if (minWidth > 0) {
    minHeight = minWidth / aspectRatio;
  } else if (minHeight > 0) {
    minWidth = minHeight * aspectRatio;
  }

  if (options.width > 0) {
    canvasWidth = options.width;
    canvasHeight = canvasWidth / aspectRatio;
  } else if (options.height > 0) {
    canvasHeight = options.height;
    canvasWidth = canvasHeight * aspectRatio;
  }

  canvasWidth = Math.min(Math.max(canvasWidth, minWidth), maxWidth);
  canvasHeight = Math.min(Math.max(canvasHeight, minHeight), maxHeight);
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  if (!isImageType(options.mimeType)) {
    options.mimeType = file.type;
  } // Converts PNG files over the `convertSize` to JPEGs.


  if (file.size > options.convertSize && options.mimeType === 'image/png') {
    options.mimeType = 'image/jpeg';
  } // If the output image is JPEG


  if (options.mimeType === 'image/jpeg') {
    // Override the default fill color (#000, black) with #fff (white)
    context.fillStyle = '#fff';
    context.fillRect(0, 0, canvasWidth, canvasHeight);
  }

  context.drawImage(image, 0, 0, canvasWidth, canvasHeight);

  if (canvas.toBlob) {
    canvas.toBlob(resolve, options.mimeType, options.quality);
  } else {
    resolve(toBlob(canvas.toDataURL(options.mimeType, options.quality)));
  }
});

var onResultCanvas = (res, _image, _options, file) => {
  var image = _image;
  var options = _options;
  var _result = res;

  if (URL) {
    URL.revokeObjectURL(image.src);
  }

  if (_result) {
    // Returns original file if the _result is greater than it and without size related options
    if (_result.size > file.size && !(options.width > 0 || options.height > 0 || options.maxWidth < Infinity || options.maxHeight < Infinity || options.minWidth > 0 || options.minHeight > 0)) {
      _result = file;
    } else {
      var date = new Date();
      _result.lastModified = date.getTime();
      _result.lastModifiedDate = date;
      _result.name = file.name;
      _result.id = file.id; // Convert the extension to match its type

      if (_result.name && _result.type !== file.type) {
        _result.name = _result.name.replace(REGEXP_EXTENSION, imageTypeToExtension(_result.type));
      }
    }
  } else {
    // Returns original file if the _result is null in some cases.
    _result = file;
  }

  if (options.success) {
    options.success(_result);
  }

  return Promise.resolve(_result);
};

var isBlob = input => {
  if (typeof Blob === 'undefined') {
    return false;
  }

  return (
    /* global Blob */
    // otherwise Blob would be marked as undefined
    input instanceof Blob || Object.prototype.toString.call(input) === '[object Blob]'
  );
};

var createPromise = (file, _options) => {
  var options = _options;

  if (!isBlob(file)) {
    return false;
  }

  if (!isImageType(file.type)) {
    return false;
  } // const image = new Image();


  var image = document.createElement('img');
  return new Promise((resolve, reject) => {
    if (URL) {
      resolve(URL.createObjectURL(file));
    } else if (FileReader) {
      var reader = new FileReader();

      reader.onload = e => resolve(e.file.result);

      reader.onabort = reject;
      reader.onerror = reject;
      reader.readAsDataURL(file);
    } else {
      // eslint-disable-next-line prefer-promise-reject-errors
      reject('The current browser does not support image compression.');
    }
  }).then(url => createImage(url, file, image)).then(_ref => {
    var {
      width,
      height
    } = _ref;
    return appendToCanvas(width, height, _options, file, image);
  }).then(res => onResultCanvas(res, image, options, file)).catch(err => {
    if (!options.error) {
      throw err;
    }

    options.error(new Error(err));
  });
};

var compressedImage = (filesList, _options) => {
  if (!filesList.length) {
    return false;
  }

  var options = _objectSpread2(_objectSpread2({}, DEFAULTS), _options);

  var promises = [];
  var files = [...filesList];
  files.forEach(file => {
    var filePromise = createPromise(file, options);

    if (filePromise) {
      promises.push(filePromise);
    }
  });
  return Promise.all(promises);
};

var createRefId = (function () {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return "".concat(prefix).concat(Math.random().toString(36).slice(2));
});

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10;

var ADD_ICON = svg([AddSvg]);
var ATTACH_FILE_ICON = svg([Attach_fileSvg]);
var DELETE_FOREVER_ICON = svg([Delete_foreverSvg]);
var CLEAR_ICON = svg([ClearSvg]);
var FILE_UPLOAD_GROUP_ICON = svg([FileUploadGroupSvg]);
var IMAGE_FILE_TYPES = 'image/jpg, image/jpeg, image/png'; // helper functions:
// bytes from kBytes

var getBytesFromKilobyte = kilobyte => 1024 * kilobyte; // find file in a list of files, returning a match (or its index) if found (undefined otherwise)

var findFileById = (files, file, indexOnly) => {
  for (var i = 0, n = files.length; i < n; i++) {
    if (files[i].id === file.id) {
      return indexOnly ? i : files[i];
    }
  }

  return undefined;
}; // find file by .id in sources and manipulate sources upon file match according to cases requested


var findAndManipulate = (sources, file, _ref) => {
  var {
    once,
    record,
    removeFrom,
    appendTo
  } = _ref;
  // set up
  var where;
  var foundAt;
  var result = [];
  var deletions = [];
  var appends = [];

  var _remove = removeFrom && new Set(removeFrom);

  var _append = appendTo && new Set(appendTo); // for all sources a.k.a. file arrays:


  for (var i = 0, n = sources.length; i < n; i++) {
    // fix a current array where....
    where = sources[i]; // ... to find the file (by comparing .id values)

    foundAt = findFileById(where, file, true); // process case 3. queue file to be appended later
    // N.B. this is the only case that's *independent* of file-found status

    if (_append && _append.has(where)) appends.push(where); // file not found?

    if (foundAt === undefined) continue; // no, skip this array
    // yes, file found - process cases:
    // 1. just record the facts

    if (record) result.push({
      where,
      foundAt
    }); // 2. queue file to be deleted later

    if (_remove && _remove.has(where)) deletions.push({
      where,
      foundAt
    }); // 4. stop at first file occurence found

    if (once) break;
  } // execute queued actions for deletion or append cases (because of unique file ids
  // we can assume each source has <= 1 occurrence of file)


  deletions.forEach(_ref2 => {
    var {
      where: _where,
      foundAt: _foundAt
    } = _ref2;
    return _where.splice(_foundAt, 1);
  }); // splice performs in-place modification!

  appends.forEach(_where => _where.push(file)); // return summary of record'ed cases

  return result;
};

class AXAFileUpload extends LitElement {
  static get tagName() {
    return 'axa-file-upload';
  }

  static get styles() {
    return css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      ", "\n    "])), unsafeCSS(styles));
  }

  static get properties() {
    return {
      invalid: {
        type: Boolean,
        reflect: true,
        defaultValue: false
      },
      allowedFileTypes: {
        type: String,
        defaultValue: ''
      },
      inputFileText: {
        type: String,
        defaultValue: 'Upload file'
      },
      maxSizeOfSingleFileKB: {
        type: Number,
        defaultValue: 100
      },
      maxSizeOfAllFilesKB: {
        type: Number,
        defaultValue: 500
      },
      maxNumberOfFiles: {
        type: Number,
        defaultValue: 10
      },
      preventFileCompression: {
        type: Boolean
      },
      icon: {
        type: String,
        defaultValue: 'cloud-upload'
      },
      deleteStatusText: {
        type: String,
        defaultValue: 'Delete'
      },
      addStatusText: {
        type: String,
        defaultValue: 'Add more'
      },
      fileTooBigStatusText: {
        type: String,
        defaultValue: 'File size exceeds maximum size'
      },
      filesTooBigStatusText: {
        type: String,
        defaultValue: 'File sizes exceed maximum size'
      },
      tooManyFilesStatusText: {
        type: String,
        defaultValue: 'You exceeded the maximum number of files'
      },
      orText: {
        type: String,
        defaultValue: 'or'
      },
      infoText: {
        type: String,
        defaultValue: 'Drag and drop to upload your file'
      },
      wrongFileTypeStatusText: {
        type: String,
        defaultValue: 'Your file does not correspond with our allowed file-types'
      },
      onFileDrop: {
        type: Function,
        attribute: false
      },
      onFileRemove: {
        type: Function,
        attribute: false
      },
      onChange: {
        type: Function,
        attribute: false
      }
    };
  }

  constructor() {
    super();
    applyDefaults(this); // User gets access to the files over these. The output varies if preventFileCompression is set

    this.files = [];
    this.faultyFiles = []; // Used for previews */

    this.validCompressedFiles = [];
    this.faultyCompressedFiles = []; // Used for calculating the file sizes */

    this.validOriginalFiles = [];
    this.faultyOriginalFiles = [];
    this.sizeOfAllFilesInBytes = 0;
    this.numberOfDroppedFiles = 0;
    this.isFileMaxReached = false;
    this.globalErrorMessage = '';
    this.showAddMoreInputFile = '';
    this.reset = this.reset.bind(this);
    defineVersioned([AXAInputFile], {
      "axa-file-upload": {
        "axa-file-upload": "5.4.3",
        "axa-input-file": "5.0.24"
      }
    }, this);
  }

  handleAddMoreInputClick() {
    // trigger input-file component after clicking the "fake" inputFile (addMoreInput)
    this.inputFile.querySelector('input').click();
  }

  handleInputFileChange(e) {
    var {
      target: {
        files
      }
    } = e;
    this.filterAndAddFiles(files);
  }

  handleDropZoneDragover(e) {
    // prevent default browser behavior of following the link that triggered the event
    e.preventDefault();

    if (!this.isFileMaxReached && !this.dropZone.classList.contains('m-file-upload__dropzone_dragover')) {
      e.dataTransfer.dropEffect = 'copy';
      this.dropZone.classList.add('m-file-upload__dropzone_dragover');
    }
  }

  handleDropZoneDragleave() {
    this.dropZone.classList.remove('m-file-upload__dropzone_dragover');
  }

  filterAndAddFiles(files) {
    if (this.allowedFileTypes !== '') {
      // filter out files with wrong MIME type
      var validFileTypesFiles = [...files].filter(file => file.type && this.allowedFileTypes.indexOf(file.type) > -1); // we have at least one wrong-MIME-type file?

      var removeGlobalMessage = true;

      if (validFileTypesFiles.length < files.length) {
        removeGlobalMessage = false;
        this.globalErrorMessage = this.wrongFileTypeStatusText;
        this.requestUpdate();
      } // we didn't filter out all the incoming files?


      if (validFileTypesFiles.length > 0) {
        this.addFiles(validFileTypesFiles, removeGlobalMessage);
      }
    } else if (files.length > 0 && this.allowedFileTypes === '') {
      this.addFiles([...files], true);
    } else {
      this.invalid = false;
      this.requestUpdate();
    }
  } // <input-file> won't be triggered on drag & drop or deleting files so we create a custom event here


  fireCustomChangeEvent() {
    this.onChange({
      detail: this.files
    });
    fireCustomEvent('change', this.files, this);
  }

  handleDropZoneDrop(e) {
    // prevent browser from displaying the file fullscreen
    e.preventDefault();
    this.dropZone.classList.remove('m-file-upload__dropzone_dragover');
    var {
      files
    } = e.dataTransfer;
    this.filterAndAddFiles(files);

    if (typeof this.onFileDrop === 'function') {
      this.onFileDrop(e);
    }
  }

  handleFileDeletion(index) {
    var deletionstart = 0;
    this.numberOfDroppedFiles = this.files.length + this.faultyFiles.length - 1;
    var allOriginalFiles = this.validOriginalFiles.concat(this.faultyOriginalFiles);

    if (index >= this.files.length) {
      deletionstart = index - this.validOriginalFiles.length;
      this.faultyOriginalFiles = this.removeValidOrFaultyFileFromArray(index, this.faultyOriginalFiles, deletionstart);
      this.faultyCompressedFiles = this.removeValidOrFaultyFileFromArray(index, this.faultyCompressedFiles, deletionstart);
    } else {
      deletionstart = index;
      this.validOriginalFiles = this.removeValidOrFaultyFileFromArray(index, this.validOriginalFiles, deletionstart);
      this.validCompressedFiles = this.removeValidOrFaultyFileFromArray(index, this.validCompressedFiles, deletionstart);

      if (this.validOriginalFiles.length + 1 === this.maxNumberOfFiles) {
        this.showAddMoreInputFile = true;
      }
    }

    if (this.preventFileCompression) {
      this.files = this.validOriginalFiles;
      this.faultyFiles = this.faultyOriginalFiles;
    } else {
      this.files = this.validCompressedFiles;
      this.faultyFiles = this.faultyCompressedFiles;
    }

    this.handleMaxNumberOfFiles();
    this.sizeOfAllFilesInBytes -= allOriginalFiles[index].size; // If all files were deleted -> go back to default screen

    if (this.files.length + this.faultyFiles.length === 0) {
      this.showFileOverview = false;
      this.sizeOfAllFilesInBytes = 0;
      this.numberOfDroppedFiles = 0;
      this.showAddMoreInputFile = false;
      this.files = [];
      this.faultyFiles = [];
      this.validOriginalFiles = [];
      this.faultyOriginalFiles = [];
      this.validCompressedFiles = [];
      this.faultyCompressedFiles = [];
    }

    this.validateOverallSize();

    if (typeof this.onFileRemove === 'function') {
      this.onFileRemove();
      this.fireCustomChangeEvent();
    }

    this.requestUpdate();
  }

  reset() {
    // delete all added files (if any)
    while (this.files.length || this.faultyFiles.length) {
      this.handleFileDeletion(0);
    }
  }

  removeValidOrFaultyFileFromArray(index, files, deletionstart) {
    var clonedFile = [...files];
    clonedFile.splice(deletionstart, 1);
    return clonedFile;
  }

  addFiles(droppedFiles, removeGlobalMessage) {
    var _this = this;

    return _asyncToGenerator(function* () {
      // generate id to match original files with compressed one if this.preventFileCompression is set
      var droppedFilesWithID = droppedFiles.map(file => {
        file.id = createRefId();
        return file;
      });
      _this.showAddMoreInputFile = true;

      if (removeGlobalMessage) {
        _this.globalErrorMessage = '';
      }

      _this.numberOfDroppedFiles += droppedFilesWithID.length;
      var notImagesFiles = [...droppedFilesWithID].filter(file => IMAGE_FILE_TYPES.indexOf(file.type) === -1); // compress all images. png's will become jpeg's and unrecognised files will be deleted. (all pdf's were removed)

      var compressedImagesWithID = yield compressedImage(droppedFilesWithID);

      _this.validateFiles(compressedImagesWithID, notImagesFiles, droppedFilesWithID);

      if ((_this.files.length > 0 || _this.faultyFiles.length > 0) && droppedFilesWithID.length > 0) {
        _this.showFileOverview = true;
      }

      if (_this.files.length >= _this.maxNumberOfFiles) {
        _this.showAddMoreInputFile = false;
      }

      _this.handleMaxNumberOfFiles();

      _this.requestUpdate();
    })();
  }

  validateOverallSize() {
    var fileSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var {
      sizeOfAllFilesInBytes,
      maxSizeOfAllFilesKB,
      filesTooBigStatusText
    } = this;
    var maxSizeOfAllFilesInBytes = getBytesFromKilobyte(maxSizeOfAllFilesKB);

    if (sizeOfAllFilesInBytes + fileSize > maxSizeOfAllFilesInBytes) {
      this.globalErrorMessage = filesTooBigStatusText;
      this.invalid = true;
    } else {
      this.globalErrorMessage = '';
      this.invalid = false;
    }
  }

  validateFiles(compressedImages, notImagesFiles, droppedFilesWithID) {
    var {
      maxSizeOfSingleFileKB
    } = this;
    var maxSizeOfSingleFileInBytes = getBytesFromKilobyte(maxSizeOfSingleFileKB);
    var faultyCompressedFiles = [];
    var validCompressedFiles = [];
    var faultyOriginalFiles = [];
    var validOriginalFiles = [];
    var newOriginalFiles = droppedFilesWithID;
    var newCompressedFiles = [...notImagesFiles].concat(compressedImages);

    for (var i = 0, n = newOriginalFiles.length; i < n; i++) {
      var file = newOriginalFiles[i];
      var fileSize = file.size;

      if (fileSize > maxSizeOfSingleFileInBytes) {
        faultyOriginalFiles.push(file);
        faultyCompressedFiles.push(findFileById(newCompressedFiles, file));
      } else {
        validOriginalFiles.push(file);
        validCompressedFiles.push(findFileById(newCompressedFiles, file));
      }

      this.sizeOfAllFilesInBytes += fileSize;
      this.validateOverallSize(fileSize);
    }

    this.addFilesToSpecificArray(validOriginalFiles, validCompressedFiles, faultyOriginalFiles, faultyCompressedFiles);
  }

  addFilesToSpecificArray(validOriginalFiles, validCompressedFiles, faultyOriginalFiles, faultyCompressedFiles) {
    var {
      maxNumberOfFiles
    } = this;
    var numberOfFilesLeftover = Math.max(maxNumberOfFiles - this.validOriginalFiles.length, 0);
    var originalFilesLeftover = validOriginalFiles.slice(0, numberOfFilesLeftover);
    var compressedFilesLeftover = validCompressedFiles.slice(0, numberOfFilesLeftover);

    if (this.preventFileCompression) {
      this.files = this.files.concat(originalFilesLeftover); // Concat the latest faulty files from a file-upload to the existing ones

      this.faultyFiles = this.faultyFiles.concat(faultyOriginalFiles);
    } else {
      // Concat the latest valid files from a file-upload to the existing ones
      this.files = this.files.concat(compressedFilesLeftover); // Concat the latest faulty files from a file-upload to the existing ones

      this.faultyFiles = this.faultyFiles.concat(faultyCompressedFiles);
    } // Used for previews


    this.validCompressedFiles = this.validCompressedFiles.concat(compressedFilesLeftover); // Used for previews

    this.faultyCompressedFiles = this.faultyCompressedFiles.concat(faultyCompressedFiles);
    this.validOriginalFiles = this.validOriginalFiles.concat(originalFilesLeftover);
    this.faultyOriginalFiles = this.faultyOriginalFiles.concat(faultyOriginalFiles);
    this.fireCustomChangeEvent();
  }

  handleMaxNumberOfFiles() {
    var {
      numberOfDroppedFiles,
      faultyFiles,
      maxNumberOfFiles,
      tooManyFilesStatusText,
      files
    } = this;

    if (numberOfDroppedFiles - faultyFiles.length > maxNumberOfFiles && faultyFiles.length + files.length >= maxNumberOfFiles) {
      this.globalErrorMessage = tooManyFilesStatusText;
      this.invalid = true;
    }

    this.isFileMaxReached = files.length === maxNumberOfFiles;
  }

  fileOverviewMapping(allCompressedFiles) {
    var {
      deleteStatusText,
      fileTooBigStatusText,
      faultyCompressedFiles,
      preventFileCompression
    } = this;
    var urlCreator = window.URL || window.webkitURL;
    var allOriginalFiles = this.validOriginalFiles.concat(this.faultyOriginalFiles);
    return allCompressedFiles.map((file, index) => {
      var isfaultyFile = false;

      if (!file) {
        return '';
      }

      for (var i = 0; i < faultyCompressedFiles.length; i++) {
        if (faultyCompressedFiles[i].id === file.id) {
          isfaultyFile = file;
          this.invalid = true;
          break;
        }
      }

      var fileName = preventFileCompression ? allOriginalFiles[index].name : file.name;
      var isNonImageFile = file.type.indexOf('application') > -1;
      var imageUrl = urlCreator.createObjectURL(file);
      return html(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n        <figure class=\"m-file-upload__img-figure js-file-upload__img-figure\">\n          <div\n            class=\"m-file-upload__icon-hover-area\"\n            @click=", "\n          >\n            ", "\n            <div class=\"m-file-upload__icon-layer\">\n              <span class=\"m-file-upload__icon-error\"\n                >", "</span\n              >\n              <span class=\"m-file-upload__icon-delete\"\n                >", "</span\n              >\n            </div>\n          </div>\n          <figcaption\n            class=\"m-file-upload__img-caption js-file-upload__img-caption\"\n            data-status=\"", "\"\n          >\n            <span\n              class=\"m-file-upload__filename js-file-upload__filename\"\n              title=\"", "\"\n              >", "</span\n            >\n            ", "\n          </figcaption>\n        </figure>\n      "])), () => this.handleFileDeletion(index), isNonImageFile ? html(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n                  <span class=\"m-file-upload__file-element\">\n                    ", "</span\n                  >\n                "])), ATTACH_FILE_ICON) : html(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n                  <img\n                    class=\"m-file-upload__img-element\"\n                    src=\"", "\"\n                    alt=\"", "\"\n                  />\n                "])), imageUrl, fileName), isfaultyFile ? CLEAR_ICON : '', DELETE_FOREVER_ICON, deleteStatusText, fileName, fileName, isfaultyFile ? html(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n                  <span\n                    class=\"m-file-upload__error js-file-upload__error\"\n                    title=\"", "\"\n                    >", "</span\n                  >\n                "])), isfaultyFile.errorMessage || fileTooBigStatusText, isfaultyFile.errorMessage || fileTooBigStatusText) : html(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([""]))));
    });
  } // invalidate an existing file by fiat. Uses file.id to match, and file.errorMessage for UI.


  invalidate(file, clear, globalErrorMessage) {
    // set up
    var {
      faultyOriginalFiles,
      faultyCompressedFiles,
      validOriginalFiles,
      validCompressedFiles,
      files,
      faultyFiles
    } = this;
    var allFileLists = [faultyOriginalFiles, faultyCompressedFiles, validOriginalFiles, validCompressedFiles, files, faultyFiles]; // try to find file via its 'id'

    var result = findAndManipulate([faultyOriginalFiles, validOriginalFiles], file, {
      once: true,
      record: true
    });
    var isFound = !!result.length; // we found it?

    if (isFound) {
      // yes, set up
      var {
        where
      } = result[0];
      var faulties = [faultyOriginalFiles, faultyCompressedFiles, faultyFiles];
      var valids = [validOriginalFiles, validCompressedFiles, files]; // did we find the file among the faulty ones?

      if (where === faultyOriginalFiles) {
        // yes, so if we are asked to clear a faulty file...
        if (clear) {
          // clear it everywhere
          findAndManipulate(allFileLists, file, {
            removeFrom: faulties,
            appendTo: valids
          }); // clear invalidity status

          this.invalid = false;
          this.globalErrorMessage = '';
        }
      } else {
        // we found the file among the valid ones.
        // Hence we are asked to mark the file everywhere as faulty
        findAndManipulate(allFileLists, file, {
          removeFrom: valids,
          appendTo: faulties
        }); // set invalidity status

        this.invalid = true;
        this.globalErrorMessage = typeof globalErrorMessage === 'string' ? globalErrorMessage : file.errorMessage;
      } // force rerender


      this.requestUpdate();
    }

    return isFound;
  }

  generateAddMoreInputFile() {
    var {
      addStatusText
    } = this;
    return html(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n      <figure\n        class=\"m-file-upload__img-figure js-file-upload__img-figure m-file-upload__add-more js-file-upload__add-more\"\n      >\n        <div\n          class=\"m-file-upload__icon-wrapper\"\n          @click=", "\n        >\n          <div class=\"m-file-upload__icon-layer\">\n            ", "\n          </div>\n        </div>\n        <figcaption\n          class=\"m-file-upload__img-caption js-file-upload__img-caption\"\n          title=\"", "\"\n        >\n          ", "\n        </figcaption>\n      </figure>\n    "])), this.handleAddMoreInputClick, ADD_ICON, addStatusText, addStatusText);
  }

  render() {
    var {
      faultyCompressedFiles,
      validCompressedFiles,
      infoText,
      orText,
      icon,
      inputFileText,
      showAddMoreInputFile,
      globalErrorMessage
    } = this;
    var fileOverviewClasses = {
      'm-file-upload__dropzone': true,
      'js-file-upload__dropzone': true,
      'm-file-upload__dropzone-file-overview': this.showFileOverview,
      'js-file-upload__dropzone-file-overview': this.showFileOverview
    }; // displaying files with errors (e.g. too big) after valid ones

    var allCompressedFiles = validCompressedFiles.concat(faultyCompressedFiles);
    var fileOverview = this.fileOverviewMapping(allCompressedFiles);
    return html(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n      <article class=\"m-file-upload js-file-upload\">\n        <h1><slot></slot></h1>\n        <section\n          @dragover=\"", "\"\n          @dragleave=\"", "\"\n          @drop=\"", "\"\n          class=\"", "\"\n        >\n          ", "\n        </section>\n\n        <div class=\"m-file-upload__error-wrapper js-file-upload__error-wrapper\">\n          ", "\n        </div>\n      </article>\n    "])), this.handleDropZoneDragover, this.handleDropZoneDragleave, this.handleDropZoneDrop, classMap(fileOverviewClasses), !this.showFileOverview ? versionedHtml(this)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n                <div>\n                  ", "\n                </div>\n                <p class=\"m-file-upload__information\">", "</p>\n                <p class=\"m-file-upload__or\">", "</p>\n                <axa-input-file\n                  class=\"m-file-upload__input js-file-upload__input\"\n                  accept=\"", "\"\n                  icon=\"", "\"\n                  multiple\n                  @change=", "\n                  variant=\"red\"\n                  text=\"", "\"\n                ></axa-input-file>\n              "])), FILE_UPLOAD_GROUP_ICON, infoText, orText, this.allowedFileTypes, icon, this.handleInputFileChange, inputFileText) : html(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n                ", "\n                ", "\n              "])), fileOverview, showAddMoreInputFile ? this.generateAddMoreInputFile() : ""), globalErrorMessage);
  }

  firstUpdated() {
    this.dropZone = this.shadowRoot.querySelector('.js-file-upload__dropzone');
    this.inputFile = this.shadowRoot.querySelector('.js-file-upload__input');
    this.errorWrapper = this.shadowRoot.querySelector('.js-file-upload__error-wrapper');
    this.fileUpload = this.shadowRoot.querySelector('.js-file-upload');
    this.addEventListener('reset', this.reset);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener('reset', this.reset);
  }

  querySelector(selector) {
    return this.shadowRoot.querySelector(selector);
  }

}

defineVersioned([AXAFileUpload], {
  "axa-file-upload": {
    "axa-file-upload": "5.4.3",
    "axa-input-file": "5.0.24"
  }
});

export default AXAFileUpload;
export { getBytesFromKilobyte };
