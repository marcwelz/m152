import val from '@skatejs/val';
import { LitElement, css, unsafeCSS, svg } from 'lit-element';
import { Expand_lessSvg, Insert_drive_fileSvg, File_downloadSvg, EmailSvg, Expand_moreSvg, Phone_iphoneSvg, Local_phoneSvg, AddSvg, SearchSvg, File_uploadSvg, Cloud_uploadSvg, Check_circleSvg, CheckSvg, Info_outlineSvg, Warning_amberSvg, CloudySvg, CloseSvg } from '@axa-ch/materials/icons/material-design';
import { ArrowLeftSvg, ArrowRightSvg } from '@axa-ch/materials/icons';
import { AxaLogoSvg, AxaLogoOpenSvg } from '@axa-ch/materials/images';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var defineOnce = ((name, customElementClass) => {
  // normalize name since HTML tag names don't allow case distinction
  var lowerCaseName = name.toLowerCase(); // custom element not already registered?

  if (!window.customElements.get(lowerCaseName)) {
    // no, register it now
    window.customElements.define(lowerCaseName, customElementClass);
  } // return its name as a convenience


  return lowerCaseName;
});

// and also not part of static template strings due to ${...} syntax!
// helper functions

var toKebabCase = dottedVersionString => "".concat(dottedVersionString).replace(/\./g, '-').replace(/[^A-Za-z0-9-]/g, '');

var versionedTag = (tagName, version) => "".concat(tagName, "-").concat(toKebabCase(version));
// API functions
// ///
// examples:
//           defineVersioned([AXADatepicker],  __ VERSION_INFO__); // main component
//           defineVersioned([AXADropdown],  __ VERSION_INFO__, this); // dependent component
//           defineVersioned([AXACheckbox], 'rsv'); // custom version


var defineVersioned = (dependencies, versionInfo, parentInstance) => {
  // set up
  var customVersion = typeof versionInfo === 'string' && versionInfo;
  var versionedTagName = ''; // process all dependant components that it lists...

  dependencies.forEach(dependency => {
    var componentClass = dependency instanceof HTMLElement ? dependency.constructor : dependency; // extract each dependant component's version

    var {
      tagName
    } = componentClass;
    var externalVersion = !customVersion && versionInfo[tagName]; // ordinary, non-POD versioning?

    if (externalVersion) {
      // yes, first time versioning/registration of this component, but its class
      // contains a PL-reserved 'versions' property?
      if (!window.customElements.get(tagName) && componentClass.versions) {
        // yes, this class is wrongly implemented - premature exit
        throw Error("'versions' is a reserved class property, but was found in ".concat(tagName, "'s class"));
      } // inject version info into component-defining class - this helps for live debugging


      componentClass.versions = externalVersion; // define its *unversioned*-tag variant first

      defineOnce(tagName, componentClass);
    } // extract each dependant component's version,


    var {
      versions
    } = componentClass; // If there is no version found, use the wrapping custom-element's version

    if (!versions && parentInstance) {
      // returns an array containing one object, which contains the tagname of the parent as key and its deployed version as value
      versions = versionInfo[parentInstance.constructor.tagName]; // extract the one item in the versions array and get only the version as string
      // eslint-disable-next-line prefer-destructuring

      versions[tagName] = Object.values(versions)[0];
    } // assembling a new, versioned name,


    var version = customVersion || versions[tagName];
    versionedTagName = versionedTag(tagName, version); // and redundantly defining
    //     versionedTagName |-> dependentComponentClass'
    // in parallel to the existing unversioned definition
    //     tagName |-> dependentComponentClass
    //
    // Note: the class expression formally creates a *new* dependentComponentClass' with identical behaviour,
    // which is needed to get around a bi-uniqueness constraint imposed by the
    // custom-elements registry, cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define
    // under section Exceptions:NotSupportedError)

    defineOnce(versionedTagName, class extends componentClass {});
  });
  return versionedTagName; // for convenience in single-component custom-versioned definitions
};

var _excluded = ["children"];

var isDefined = value => !(value === undefined || value === null);

var pascalCase = hyphenatedName => hyphenatedName.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join(''); // generic defaults (will be applied in the absence of explicit 'defaultValue')
// (IE11 does not support new Map([iterable]), so we have to initialize the map
// with .set calls for each key)


var DEFAULT_VALUE_OF_TYPE = new Map();
[[String, ''], [Boolean, false], [Object, {}], [Array, []], [Number, 0], [Function, () => {}]].forEach(_ref => {
  var [key, value] = _ref;
  DEFAULT_VALUE_OF_TYPE.set(key, value);
});

var emptyFunction = () => {}; // convert *attribute* value


var convert = (value, type) => {
  if (type === Number) {
    return parseFloat(value);
  }

  if (type === Function) {
    // corner case: inline event handlers like onchange="alert(event)" cannot be reliably converted from string,
    // so just return an empty function s.t.  event-handler invocations in component code don't throw exceptions
    // (components are responsible for firing synthetic events on their root element instead to trigger expected
    // inline event handlers)
    return emptyFunction;
  }

  return type === Array || type === Object ? JSON.parse(value) : value;
};

var applyDefaults = ceInst => {
  var {
    constructor: {
      properties
    }
  } = ceInst; // get all properties of the custom element and loop over each key

  Object.keys(properties).forEach(property => {
    // extract default value and property type
    var propertyValue = properties[property];
    var {
      type,
      converter,
      defaultValue
    } = propertyValue;

    if (!type) {
      if (!converter) {
        throw new Error("<".concat(ceInst.nodeName, "> property \"").concat(property, "\" is missing a type!"));
      }

      return;
    } // respect property values defined before CE is constructed


    var value = ceInst[property];

    if (isDefined(value)) {
      return;
    } // Boolean attributes in HTML are true if present, false otherwise.
    // For all other types, get their value as string...


    value = type === Boolean ? ceInst.hasAttribute(property) : ceInst.getAttribute(property); // .. and if defined

    if (isDefined(value)) {
      // convert it
      ceInst[property] = convert(value, type);
      return;
    } // otherwise, apply default
    // make sure the set value() function is never triggered when defaultValue
    // is undefined otherwise the isControlled flag and firstTime flag are messed up in
    // some components containing controlledness. Writing undefined again on value counts as change


    if (defaultValue === undefined && 'defaultValue' in propertyValue) {
      return;
    } // component author explicitly specified a default value for this property?
    // (This allows *all* values as defaults, *including* undefined. The latter is
    // the proper default for 'value' properties in React's controlled-component mode.)
    // no, derive it from general per-type defaults


    ceInst[property] = 'defaultValue' in propertyValue // component author wants full control of their default value?
    ? defaultValue // yes, apply it
    : DEFAULT_VALUE_OF_TYPE.get(type);
  });
};

var transformStylesObjectToString = value => {
  // {width: "500px"} -> width:500px;
  var styleString = Object.keys(value).reduce((prev, curr) => {
    var previousValue = prev;
    return "".concat(previousValue += curr.split(/(?=[A-Z])/).join('-').toLowerCase(), ":").concat(value[curr], ";");
  }, '');
  return styleString;
};

var distributeProperties = (properties, componentClass) => {
  // initialize
  var attrs = {};
  var props = {};
  var map; // iterate over all properties

  Object.keys(properties).forEach(name => {
    var value = properties[name]; // classify property by type to select correct map object
    // (note that unregistered properties are classified as attr(ibute)s via their undefined .type)

    var type;
    var declaredProperty = componentClass.properties[name] || {};
    var {
      type: declaredType
    } = declaredProperty;
    var looksLikeAnEventHandler = name.indexOf('on') === 0 && // starts with on...
    name.charAt(2) === name.charAt(2).toUpperCase(); // continues with uppercase-letter, i.e. camelCase

    if (looksLikeAnEventHandler) {
      type = Function;
    } else if (name === 'className') {
      type = 'className';
    } else {
      type = declaredType;
    }

    switch (type) {
      case 'className':
      case Array:
      case Object:
      case Function:
      case Boolean:
        map = props;
        break;

      default:
        map = declaredType ? props : attrs;
    } // map property name to value *unless* value is undefined


    if (value !== undefined) {
      if (name === 'style') {
        map[name] = transformStylesObjectToString(value);
      } else {
        map[name] = value;
      }
    }
  });
  return {
    attrs,
    props
  };
};

var withReact = ((createElement, componentClass, version) => {
  var {
    tagName
  } = componentClass;
  var finalTagName = version ? defineVersioned([componentClass], version) : tagName;
  var displayName = pascalCase(finalTagName);

  var reactStatelessComponent = _ref2 => {
    var {
      children
    } = _ref2,
        properties = _objectWithoutProperties(_ref2, _excluded);

    var {
      attrs,
      props
    } = distributeProperties(properties, componentClass);
    return val(createElement)(finalTagName, _objectSpread2({
      isReact: true,
      attrs
    }, props), children);
  }; // displayName is important for React testing (e.g. enzyme) and Chrome DevTools plugins


  reactStatelessComponent.displayName = displayName;
  return reactStatelessComponent;
});

var iconCSS = ":host(:not([size=original])) svg {\n  width: 24px;\n  height: 24px;\n}\n\n:host([size=small]) svg {\n  width: 20px;\n  height: 20px;\n}\n\n:host([size=large]) svg {\n  width: 32px;\n  height: 32px;\n}";

function xhrCall(url) {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);

    xhr.onload = () => resolve(xhr.responseText);

    xhr.onerror = () => reject(xhr.statusText);

    xhr.send();
  });
}

var _templateObject;

class AXAIcon extends LitElement {
  static get tagName() {
    return 'axa-icon';
  }

  static get styles() {
    return css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      ", "\n    "])), unsafeCSS(iconCSS));
  }

  static get iconsMapping() {
    return {
      'arrow-left': ArrowLeftSvg,
      'arrow-right': ArrowRightSvg,
      collapse: Expand_lessSvg,
      document: Insert_drive_fileSvg,
      download: File_downloadSvg,
      email: EmailSvg,
      expand: Expand_moreSvg,
      mobile: Phone_iphoneSvg,
      phone: Local_phoneSvg,
      add: AddSvg,
      search: SearchSvg,
      upload: File_uploadSvg,
      'cloud-upload': Cloud_uploadSvg,
      'axa-logo': AxaLogoSvg,
      'axa-logo-open': AxaLogoOpenSvg,
      'check-circle': Check_circleSvg,
      check: CheckSvg,
      'info-outline': Info_outlineSvg,
      'warning-amber': Warning_amberSvg,
      cloudy: CloudySvg,
      close: CloseSvg
    };
  }

  static get properties() {
    return {
      icon: {
        type: String
      },
      size: {
        type: String,
        reflect: true,
        defaultValue: 'medium'
      },
      _loadedSvg: {
        type: String
      }
    };
  }

  constructor() {
    super();
    applyDefaults(this);
  }

  updated() {
    var {
      icon
    } = this;

    if (/\.svg/.test(icon)) {
      xhrCall(icon).then(result => {
        this._loadedSvg = result;
      });
    } else if (/<svg/.test(icon)) {
      this._loadedSvg = icon;
    } else {
      this._loadedSvg = AXAIcon.iconsMapping[icon] || '';
    }
  }

  render() {
    return this._loadedSvg && svg([this._loadedSvg]);
  }

}

defineVersioned([AXAIcon], {
  "axa-icon": {
    "axa-icon": "6.1.1"
  }
});

var index_react = ((createElement, version) => withReact(createElement, AXAIcon, version));

export default index_react;
