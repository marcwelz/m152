import val from '@skatejs/val';
import { html, LitElement } from 'lit-element';
import AXAIcon from '@axa-ch/icon';
import { classMap } from 'lit-html/directives/class-map';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var defineOnce = ((name, customElementClass) => {
  // normalize name since HTML tag names don't allow case distinction
  var lowerCaseName = name.toLowerCase(); // custom element not already registered?

  if (!window.customElements.get(lowerCaseName)) {
    // no, register it now
    window.customElements.define(lowerCaseName, customElementClass);
  } // return its name as a convenience


  return lowerCaseName;
});

var RESERVED_CHARACTER = '{'; // not allowed in HTML tags or their attributes ...
// and also not part of static template strings due to ${...} syntax!
// helper functions

var toKebabCase = dottedVersionString => "".concat(dottedVersionString).replace(/\./g, '-').replace(/[^A-Za-z0-9-]/g, '');

var versionedTag = (tagName, version) => "".concat(tagName, "-").concat(toKebabCase(version));

var extractDependencies = componentClass => {
  var {
    versions,
    tagName
  } = componentClass; // extract all dependencies...

  var dependencies = Object.keys(versions) // ... by comparing with master-component tag name
  .filter(name => name !== tagName) // ... and sorting longest-first (e.g. axa-button-link comes before axa-button)
  .sort((a, b) => b.length - a.length); // pair the list of dependency tag names with their versions

  return [dependencies, dependencies.map(_tagName => versions[_tagName])];
};

var oldTag = function oldTag(tagName) {
  var closing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var openingBracket = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '<';
  return "".concat(openingBracket).concat(closing).concat(tagName);
}; // How to make a new tag? It's tempting to just append the version info.
// However, we don't want to rewrite tags more than once: given axa-button-link in version 6.3.4
// and axa-button in version 5.0.9, we DONT'T WANT
// <axa-button-link =1> <axa-button-link-6-3-4 =2> <axa-button-5-0-9-link-6-3-4.
// So, the simplest solution replaces a rewritten tag in such a way that it does not START
// like any other tag, using a reserved character '{'. To continue with our example, we might have
// <axa-button-link =1> {axa-button-link-6-3-4. Then the erroneous rewriting step =2> can no longer match.
// Of course, in the end we need a bulk replacement of the '{'s by their original '<'s, which is simple.


var newTag = (tagName, aVersion, closing) => oldTag(versionedTag(tagName, aVersion), closing, RESERVED_CHARACTER); // Example: someStrings = ['<div><axa-dropdown .items="','" </axa-dropdown></div>']
//          aTagname = 'axa-dropdown', aVersion = '7.0.2'
//
// Rewritten as           ['<div><axa-dropdown-7-0-2 .items="','" </axa-dropdown-7-0-2></div>'].
//
// Note: this uses the split-join technique to perform global string substitution
// without needing the special-character escaping necessary for
// a reg-exp-based alternative (the latter is marginally faster, but our strings here are short)


var rewrite = (someStrings, aTagName, aVersion) => someStrings.map(string => string.split(oldTag(aTagName)).join(newTag(aTagName, aVersion)).split(oldTag(aTagName, '/')).join(newTag(aTagName, aVersion, '/'))); // ///
// API functions
// ///
// examples:
//           defineVersioned([AXADatepicker],  __ VERSION_INFO__); // main component
//           defineVersioned([AXADropdown],  __ VERSION_INFO__, this); // dependent component
//           defineVersioned([AXACheckbox], 'rsv'); // custom version


var defineVersioned = (dependencies, versionInfo, parentInstance) => {
  // set up
  var customVersion = typeof versionInfo === 'string' && versionInfo;
  var versionedTagName = ''; // process all dependant components that it lists...

  dependencies.forEach(dependency => {
    var componentClass = dependency instanceof HTMLElement ? dependency.constructor : dependency; // extract each dependant component's version

    var {
      tagName
    } = componentClass;
    var externalVersion = !customVersion && versionInfo[tagName]; // ordinary, non-POD versioning?

    if (externalVersion) {
      // yes, first time versioning/registration of this component, but its class
      // contains a PL-reserved 'versions' property?
      if (!window.customElements.get(tagName) && componentClass.versions) {
        // yes, this class is wrongly implemented - premature exit
        throw Error("'versions' is a reserved class property, but was found in ".concat(tagName, "'s class"));
      } // inject version info into component-defining class - this helps for live debugging


      componentClass.versions = externalVersion; // define its *unversioned*-tag variant first

      defineOnce(tagName, componentClass);
    } // extract each dependant component's version,


    var {
      versions
    } = componentClass; // If there is no version found, use the wrapping custom-element's version

    if (!versions && parentInstance) {
      // returns an array containing one object, which contains the tagname of the parent as key and its deployed version as value
      versions = versionInfo[parentInstance.constructor.tagName]; // extract the one item in the versions array and get only the version as string
      // eslint-disable-next-line prefer-destructuring

      versions[tagName] = Object.values(versions)[0];
    } // assembling a new, versioned name,


    var version = customVersion || versions[tagName];
    versionedTagName = versionedTag(tagName, version); // and redundantly defining
    //     versionedTagName |-> dependentComponentClass'
    // in parallel to the existing unversioned definition
    //     tagName |-> dependentComponentClass
    //
    // Note: the class expression formally creates a *new* dependentComponentClass' with identical behaviour,
    // which is needed to get around a bi-uniqueness constraint imposed by the
    // custom-elements registry, cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define
    // under section Exceptions:NotSupportedError)

    defineOnce(versionedTagName, class extends componentClass {});
  });
  return versionedTagName; // for convenience in single-component custom-versioned definitions
};

var versionedHtml = componentInstance => function (strings) {
  // derive class from instance
  var componentClass = componentInstance.constructor; // extract dependency info by looking at versions of component

  var [tagNames, versions] = extractDependencies(componentClass); // rewrite incoming array of static parts of template literals
  // in such a way that tags of dependent components are versioned:

  var newStrings = strings; // 1. rewriting proper, turning tags into versioned ones with funny initial brackets (see newTag(...) above)

  for (var i = 0, n = tagNames.length; i < n; i++) {
    newStrings = rewrite(newStrings, tagNames[i], versions[i]);
  } // 2. finish rewriting by converting funny initial brackets back to standard ones


  for (var _i = 0, _n = newStrings.length; _i < _n; _i++) {
    newStrings[_i] = newStrings[_i].split(RESERVED_CHARACTER).join('<');
  } // let lit-html see the rewritten static parts together with the
  // unchanged dynamic arg(ument)s


  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return html(newStrings, ...args);
};

var _excluded = ["children"];

var isDefined = value => !(value === undefined || value === null);

var pascalCase = hyphenatedName => hyphenatedName.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join(''); // generic defaults (will be applied in the absence of explicit 'defaultValue')
// (IE11 does not support new Map([iterable]), so we have to initialize the map
// with .set calls for each key)


var DEFAULT_VALUE_OF_TYPE = new Map();
[[String, ''], [Boolean, false], [Object, {}], [Array, []], [Number, 0], [Function, () => {}]].forEach(_ref => {
  var [key, value] = _ref;
  DEFAULT_VALUE_OF_TYPE.set(key, value);
});

var emptyFunction = () => {}; // convert *attribute* value


var convert = (value, type) => {
  if (type === Number) {
    return parseFloat(value);
  }

  if (type === Function) {
    // corner case: inline event handlers like onchange="alert(event)" cannot be reliably converted from string,
    // so just return an empty function s.t.  event-handler invocations in component code don't throw exceptions
    // (components are responsible for firing synthetic events on their root element instead to trigger expected
    // inline event handlers)
    return emptyFunction;
  }

  return type === Array || type === Object ? JSON.parse(value) : value;
};

var applyDefaults = ceInst => {
  var {
    constructor: {
      properties
    }
  } = ceInst; // get all properties of the custom element and loop over each key

  Object.keys(properties).forEach(property => {
    // extract default value and property type
    var propertyValue = properties[property];
    var {
      type,
      converter,
      defaultValue
    } = propertyValue;

    if (!type) {
      if (!converter) {
        throw new Error("<".concat(ceInst.nodeName, "> property \"").concat(property, "\" is missing a type!"));
      }

      return;
    } // respect property values defined before CE is constructed


    var value = ceInst[property];

    if (isDefined(value)) {
      return;
    } // Boolean attributes in HTML are true if present, false otherwise.
    // For all other types, get their value as string...


    value = type === Boolean ? ceInst.hasAttribute(property) : ceInst.getAttribute(property); // .. and if defined

    if (isDefined(value)) {
      // convert it
      ceInst[property] = convert(value, type);
      return;
    } // otherwise, apply default
    // make sure the set value() function is never triggered when defaultValue
    // is undefined otherwise the isControlled flag and firstTime flag are messed up in
    // some components containing controlledness. Writing undefined again on value counts as change


    if (defaultValue === undefined && 'defaultValue' in propertyValue) {
      return;
    } // component author explicitly specified a default value for this property?
    // (This allows *all* values as defaults, *including* undefined. The latter is
    // the proper default for 'value' properties in React's controlled-component mode.)
    // no, derive it from general per-type defaults


    ceInst[property] = 'defaultValue' in propertyValue // component author wants full control of their default value?
    ? defaultValue // yes, apply it
    : DEFAULT_VALUE_OF_TYPE.get(type);
  });
};

var transformStylesObjectToString = value => {
  // {width: "500px"} -> width:500px;
  var styleString = Object.keys(value).reduce((prev, curr) => {
    var previousValue = prev;
    return "".concat(previousValue += curr.split(/(?=[A-Z])/).join('-').toLowerCase(), ":").concat(value[curr], ";");
  }, '');
  return styleString;
};

var distributeProperties = (properties, componentClass) => {
  // initialize
  var attrs = {};
  var props = {};
  var map; // iterate over all properties

  Object.keys(properties).forEach(name => {
    var value = properties[name]; // classify property by type to select correct map object
    // (note that unregistered properties are classified as attr(ibute)s via their undefined .type)

    var type;
    var declaredProperty = componentClass.properties[name] || {};
    var {
      type: declaredType
    } = declaredProperty;
    var looksLikeAnEventHandler = name.indexOf('on') === 0 && // starts with on...
    name.charAt(2) === name.charAt(2).toUpperCase(); // continues with uppercase-letter, i.e. camelCase

    if (looksLikeAnEventHandler) {
      type = Function;
    } else if (name === 'className') {
      type = 'className';
    } else {
      type = declaredType;
    }

    switch (type) {
      case 'className':
      case Array:
      case Object:
      case Function:
      case Boolean:
        map = props;
        break;

      default:
        map = declaredType ? props : attrs;
    } // map property name to value *unless* value is undefined


    if (value !== undefined) {
      if (name === 'style') {
        map[name] = transformStylesObjectToString(value);
      } else {
        map[name] = value;
      }
    }
  });
  return {
    attrs,
    props
  };
};

var withReact = ((createElement, componentClass, version) => {
  var {
    tagName
  } = componentClass;
  var finalTagName = version ? defineVersioned([componentClass], version) : tagName;
  var displayName = pascalCase(finalTagName);

  var reactStatelessComponent = _ref2 => {
    var {
      children
    } = _ref2,
        properties = _objectWithoutProperties(_ref2, _excluded);

    var {
      attrs,
      props
    } = distributeProperties(properties, componentClass);
    return val(createElement)(finalTagName, _objectSpread2({
      isReact: true,
      attrs
    }, props), children);
  }; // displayName is important for React testing (e.g. enzyme) and Chrome DevTools plugins


  reactStatelessComponent.displayName = displayName;
  return reactStatelessComponent;
});

var createRefId = (function () {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return "".concat(prefix).concat(Math.random().toString(36).slice(2));
});

/* base class for non-ShadowDom components */
// map: customElementTagName |-> (ownerDocument |-> {referenceCount,style})

var crossTagReferenceCounts = {}; // BASE CLASS

class InlineStyles extends LitElement {
  /* append inline styles iff first instance in current document/ShadowRoot */
  inlineStyles() {
    var staticProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'styles';
    // get this node's document or ShadowRoot, to be used as map key to attach
    // reference-count metadata to
    // N.B. getRootNode needs polyfill for non-Chromium Edge / IE
    // (https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode)
    var root = this.getRootNode(); // retrieve all reference counts by tag name, initializing as needed
    // with WeakMap(). WeakMap (supported by IE11) acts as defense-in-depth
    // against memory leaks if disconnectedCallback is never called
    // (allowed by the spec).

    var referenceCounts = crossTagReferenceCounts[this.tagName] || new WeakMap(); // one more reference, caused by this instance

    var info = referenceCounts.get(root) || {};
    var referenceCount = (info.referenceCount || 0) + 1;
    info.referenceCount = referenceCount; // persist reference-count metadata

    referenceCounts.set(root, referenceCount);
    crossTagReferenceCounts[this.tagName] = referenceCounts; // no style sheet attached sofar?

    if (referenceCount === 1) {
      // remember our root in the instance, if not available natively
      // (ownerDocument), for DOM-removal-time cleanup.
      if (this.ownerDocument !== root) {
        this._rootNode = root;
      } // provision inline style sheet with *string* content
      // from the class property 'styles'


      var style = document.createElement('style');
      var cssAsString = this.constructor[staticProps]; // version the CSS rule selectors, if component
      // does not bear its generic name

      var versionedComponentName = this.nodeName.toLowerCase(); // e.g. axa-datepicker-7-0-2

      var genericComponentName = this.constructor.tagName; // e.g. axa-datepicker

      if (versionedComponentName !== genericComponentName) {
        // in non-ShadowDOM components, the leftmost rule-selector item
        // is the component name itself, serving as a poor-man's rule scoping construct.
        // E.g. datepicker rules are assumed to look like this:
        // axa-datepicker .class1 .... classN { ... }
        cssAsString = cssAsString.split(genericComponentName).join(versionedComponentName); // now, after the above string-to-string transformation they look like this:
        // axa-datepicker-7-0-2 .class1 .... classN { ... }
      }

      style.textContent = cssAsString;
      style.dataset.name = this.tagName.toLowerCase(); // for testing/debugging purposes
      // append it at the right place, *outside* of this instance's children
      // eslint-disable-next-line no-undef

      var parent = root instanceof ShadowRoot ? root : document.head;
      parent.appendChild(style);
      info.style = style;
    } // persist reference-count metadata


    referenceCounts.set(root, info);
    crossTagReferenceCounts[this.tagName] = referenceCounts;
  }
  /* DOM-removal cleanup in module globals */


  disconnectedCallback() {
    super.disconnectedCallback(); // if applicable, prepare reference-count metadata

    var referenceCounts = crossTagReferenceCounts[this.tagName];

    if (!referenceCounts) {
      return;
    }

    var root = this._rootNode || this.ownerDocument;
    var info = referenceCounts.get(root) || {};
    var referenceCount = (info.referenceCount || 0) - 1; // remove or update reference-count metadata

    if (referenceCount < 1) {
      referenceCounts.delete(root); // give an early hint to GC

      var {
        style
      } = info;

      if (style && style.parentNode) {
        style.parentNode.removeChild(style); // remove style node as well
      }
    } else {
      info.referenceCount = referenceCount;
      referenceCounts.set(root, info);
    }
  }

}

/* base class for non-ShadowDom components */
class NoShadowDOM extends InlineStyles {
  /* apply styles */
  connectedCallback() {
    super.connectedCallback();
    this.inlineStyles(); // contains built-in deduplication, so is
    // robust against multiple invocations of connectedCallback
    // (allowed by the spec)
  }
  /* render template in light DOM */


  createRenderRoot() {
    return this;
  }

}

var styles = "axa-input-file {\n  display: inline-block;\n  vertical-align: bottom;\n}\n\n.a-input-file {\n  font-size: 14px;\n  letter-spacing: 0.02em;\n  line-height: 17px;\n  font-family: \"Source Sans Pro\", Arial, sans-serif;\n  position: relative;\n  display: inline-block;\n  width: 100%;\n  text-align: center;\n  box-sizing: border-box;\n  padding: 0 30px;\n  margin: 0;\n  min-height: 40px;\n  vertical-align: bottom;\n  -webkit-hyphens: auto;\n      -ms-hyphens: auto;\n          hyphens: auto;\n  overflow-wrap: break-word;\n  word-wrap: break-word;\n  text-transform: uppercase;\n  color: #fff;\n  background-color: #00008f;\n  border: solid 2px #00008f;\n  border-bottom-color: #00005b;\n}\n.a-input-file__flex-wrapper {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  min-height: 36px;\n  height: 35px;\n  box-sizing: border-box;\n}\n.a-input-file:hover, .a-input-file:active, .a-input-file:focus {\n  cursor: pointer;\n  text-decoration: none;\n  background-color: #00005b;\n  border-color: #00005b;\n}\n.a-input-file__icon {\n  display: flex;\n  margin-right: 10px;\n}\n.a-input-file__input {\n  width: 0.001px;\n  height: 0.001px;\n  opacity: 0;\n  overflow: hidden;\n  position: absolute;\n  z-index: -1;\n}\n\n.a-input-file--large .a-input-file__flex-wrapper {\n  min-height: 50px;\n  font-size: 16px;\n  letter-spacing: 0.02em;\n  line-height: 24px;\n  font-family: \"Source Sans Pro\", Arial, sans-serif;\n}\n\n.a-input-file--motion {\n  z-index: 0;\n  overflow: hidden;\n  transition: color 0.3s cubic-bezier(0.455, 0.03, 0.515, 0.955) 0s;\n}\n.a-input-file--motion::after {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  z-index: -1;\n  display: block;\n  width: 0.001px;\n  height: 100vw;\n  content: \"\";\n  transform: translateX(-50%) translateY(-50%) rotate(45deg);\n  transition: width 0.3s cubic-bezier(0.455, 0.03, 0.515, 0.955) 0s;\n  background-color: #00005b;\n}\n.a-input-file--motion:hover, .a-input-file--motion:focus {\n  background-color: #00008f;\n  color: #fff;\n}\n.a-input-file--motion:hover::after, .a-input-file--motion:focus::after {\n  width: 110%;\n  background-color: #00005b;\n}\n\n.a-input-file--red {\n  background-color: #f07662;\n  border-color: #f07662;\n  border-bottom-color: #ec4d33;\n}\n.a-input-file--red:hover, .a-input-file--red:active, .a-input-file--red:focus {\n  background-color: #ec4d33;\n  border-color: #ec4d33;\n}\n.a-input-file--red.a-input-file--motion::after {\n  background-color: #ec4d33;\n}\n.a-input-file--red.a-input-file--motion:hover, .a-input-file--red.a-input-file--motion:focus {\n  background-color: #f07662;\n  color: #fff;\n}\n.a-input-file--red.a-input-file--motion:hover::after, .a-input-file--red.a-input-file--motion:focus::after {\n  background-color: #ec4d33;\n}\n\n.a-input-file--secondary {\n  background-color: transparent;\n  border-bottom-color: #00008f;\n  color: #00008f;\n}\n.a-input-file--secondary:hover, .a-input-file--secondary:active, .a-input-file--secondary:focus {\n  color: #fff;\n}\n.a-input-file--secondary.a-input-file--motion {\n  background-color: transparent;\n}\n\n.a-input-file--inverted {\n  background-color: transparent;\n  border-color: #fff;\n  color: #fff;\n}\n.a-input-file--inverted:hover, .a-input-file--inverted:active, .a-input-file--inverted:focus {\n  background-color: #fff;\n  border-color: #fff;\n  color: #00005b;\n}\n.a-input-file--inverted.a-input-file--motion {\n  background-color: transparent;\n}\n.a-input-file--inverted.a-input-file--motion::after {\n  background-color: #fff;\n}\n\n.a-input-file--disabled {\n  color: #999;\n  background-color: #e5e5e5;\n  border-color: #e5e5e5;\n  border-bottom-color: #ccc;\n  pointer-events: none;\n}";

var _templateObject, _templateObject2;
var TYPE = 'file';

class AXAInputFile extends NoShadowDOM {
  static get tagName() {
    return 'axa-input-file';
  }

  static get styles() {
    return styles;
  }

  static get properties() {
    return {
      text: {
        type: String
      },
      variant: {
        type: String
      },
      icon: {
        type: String
      },
      refId: {
        type: String,
        defaultValue: "input-file-".concat(createRefId())
      },
      large: {
        type: Boolean
      },
      motionOff: {
        type: Boolean
      },
      disabled: {
        type: Boolean,
        reflect: true
      },
      accept: {
        type: String,
        defaultValue: 'image/jpg, image/jpeg, application/pdf, image/png'
      },
      capture: {
        type: Boolean
      },
      multiple: {
        type: Boolean
      },
      onChange: {
        type: Function,
        attribute: false
      }
    };
  }

  constructor() {
    super();
    applyDefaults(this);
    defineVersioned([AXAIcon], {
      "axa-input-file": {
        "axa-input-file": "5.0.24",
        "axa-icon": "6.1.1"
      }
    }, this);
  }

  render() {
    var {
      text = '',
      large,
      motionOff,
      disabled,
      variant = '',
      icon = '',
      accept,
      capture,
      multiple
    } = this;
    var classes = {
      'a-input-file--secondary': variant === 'secondary',
      'a-input-file--red': variant === 'red',
      'a-input-file--inverted': variant === 'inverted',
      'a-input-file--large': large,
      'a-input-file--motion': !motionOff,
      'a-input-file--disabled': disabled
    };
    return html(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      <label class=\"a-input-file ", "\" for=\"", "\">\n        <span class=\"a-input-file__flex-wrapper\">\n          ", "\n          ", "\n        </span>\n      </label>\n      <input\n        type=\"", "\"\n        accept=\"", "\"\n        ?multiple=\"", "\"\n        ?capture=\"", "\"\n        @change=\"", "\"\n        class=\"a-input-file__input js-input-file__input\"\n        id=\"", "\"\n      />\n    "])), classMap(classes), this.refId, icon && versionedHtml(this)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n              <axa-icon class=\"a-input-file__icon js-input-file__icon\" icon=\"", "\"></axa-icon>\n            "])), icon), text, TYPE, accept, multiple, capture, this.onChange, this.refId);
  }

}

defineVersioned([AXAInputFile], {
  "axa-input-file": {
    "axa-input-file": "5.0.24",
    "axa-icon": "6.1.1"
  }
});

var index_react = ((createElement, version) => withReact(createElement, AXAInputFile, version));

export default index_react;
