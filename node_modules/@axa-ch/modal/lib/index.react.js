import val from '@skatejs/val';
import { LitElement, css, unsafeCSS, html, svg } from 'lit-element';
import closeIcon from '@axa-ch/materials/icons/material-design/close.svg';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var defineOnce = ((name, customElementClass) => {
  // normalize name since HTML tag names don't allow case distinction
  var lowerCaseName = name.toLowerCase(); // custom element not already registered?

  if (!window.customElements.get(lowerCaseName)) {
    // no, register it now
    window.customElements.define(lowerCaseName, customElementClass);
  } // return its name as a convenience


  return lowerCaseName;
});

// and also not part of static template strings due to ${...} syntax!
// helper functions

var toKebabCase = dottedVersionString => "".concat(dottedVersionString).replace(/\./g, '-').replace(/[^A-Za-z0-9-]/g, '');

var versionedTag = (tagName, version) => "".concat(tagName, "-").concat(toKebabCase(version));
// API functions
// ///
// examples:
//           defineVersioned([AXADatepicker],  __ VERSION_INFO__); // main component
//           defineVersioned([AXADropdown],  __ VERSION_INFO__, this); // dependent component
//           defineVersioned([AXACheckbox], 'rsv'); // custom version


var defineVersioned = (dependencies, versionInfo, parentInstance) => {
  // set up
  var customVersion = typeof versionInfo === 'string' && versionInfo;
  var versionedTagName = ''; // process all dependant components that it lists...

  dependencies.forEach(dependency => {
    var componentClass = dependency instanceof HTMLElement ? dependency.constructor : dependency; // extract each dependant component's version

    var {
      tagName
    } = componentClass;
    var externalVersion = !customVersion && versionInfo[tagName]; // ordinary, non-POD versioning?

    if (externalVersion) {
      // yes, first time versioning/registration of this component, but its class
      // contains a PL-reserved 'versions' property?
      if (!window.customElements.get(tagName) && componentClass.versions) {
        // yes, this class is wrongly implemented - premature exit
        throw Error("'versions' is a reserved class property, but was found in ".concat(tagName, "'s class"));
      } // inject version info into component-defining class - this helps for live debugging


      componentClass.versions = externalVersion; // define its *unversioned*-tag variant first

      defineOnce(tagName, componentClass);
    } // extract each dependant component's version,


    var {
      versions
    } = componentClass; // If there is no version found, use the wrapping custom-element's version

    if (!versions && parentInstance) {
      // returns an array containing one object, which contains the tagname of the parent as key and its deployed version as value
      versions = versionInfo[parentInstance.constructor.tagName]; // extract the one item in the versions array and get only the version as string
      // eslint-disable-next-line prefer-destructuring

      versions[tagName] = Object.values(versions)[0];
    } // assembling a new, versioned name,


    var version = customVersion || versions[tagName];
    versionedTagName = versionedTag(tagName, version); // and redundantly defining
    //     versionedTagName |-> dependentComponentClass'
    // in parallel to the existing unversioned definition
    //     tagName |-> dependentComponentClass
    //
    // Note: the class expression formally creates a *new* dependentComponentClass' with identical behaviour,
    // which is needed to get around a bi-uniqueness constraint imposed by the
    // custom-elements registry, cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define
    // under section Exceptions:NotSupportedError)

    defineOnce(versionedTagName, class extends componentClass {});
  });
  return versionedTagName; // for convenience in single-component custom-versioned definitions
};

var _excluded = ["children"];

var isDefined = value => !(value === undefined || value === null);

var pascalCase = hyphenatedName => hyphenatedName.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join(''); // generic defaults (will be applied in the absence of explicit 'defaultValue')
// (IE11 does not support new Map([iterable]), so we have to initialize the map
// with .set calls for each key)


var DEFAULT_VALUE_OF_TYPE = new Map();
[[String, ''], [Boolean, false], [Object, {}], [Array, []], [Number, 0], [Function, () => {}]].forEach(_ref => {
  var [key, value] = _ref;
  DEFAULT_VALUE_OF_TYPE.set(key, value);
});

var emptyFunction = () => {}; // convert *attribute* value


var convert = (value, type) => {
  if (type === Number) {
    return parseFloat(value);
  }

  if (type === Function) {
    // corner case: inline event handlers like onchange="alert(event)" cannot be reliably converted from string,
    // so just return an empty function s.t.  event-handler invocations in component code don't throw exceptions
    // (components are responsible for firing synthetic events on their root element instead to trigger expected
    // inline event handlers)
    return emptyFunction;
  }

  return type === Array || type === Object ? JSON.parse(value) : value;
};

var applyDefaults = ceInst => {
  var {
    constructor: {
      properties
    }
  } = ceInst; // get all properties of the custom element and loop over each key

  Object.keys(properties).forEach(property => {
    // extract default value and property type
    var propertyValue = properties[property];
    var {
      type,
      converter,
      defaultValue
    } = propertyValue;

    if (!type) {
      if (!converter) {
        throw new Error("<".concat(ceInst.nodeName, "> property \"").concat(property, "\" is missing a type!"));
      }

      return;
    } // respect property values defined before CE is constructed


    var value = ceInst[property];

    if (isDefined(value)) {
      return;
    } // Boolean attributes in HTML are true if present, false otherwise.
    // For all other types, get their value as string...


    value = type === Boolean ? ceInst.hasAttribute(property) : ceInst.getAttribute(property); // .. and if defined

    if (isDefined(value)) {
      // convert it
      ceInst[property] = convert(value, type);
      return;
    } // otherwise, apply default
    // make sure the set value() function is never triggered when defaultValue
    // is undefined otherwise the isControlled flag and firstTime flag are messed up in
    // some components containing controlledness. Writing undefined again on value counts as change


    if (defaultValue === undefined && 'defaultValue' in propertyValue) {
      return;
    } // component author explicitly specified a default value for this property?
    // (This allows *all* values as defaults, *including* undefined. The latter is
    // the proper default for 'value' properties in React's controlled-component mode.)
    // no, derive it from general per-type defaults


    ceInst[property] = 'defaultValue' in propertyValue // component author wants full control of their default value?
    ? defaultValue // yes, apply it
    : DEFAULT_VALUE_OF_TYPE.get(type);
  });
};

var transformStylesObjectToString = value => {
  // {width: "500px"} -> width:500px;
  var styleString = Object.keys(value).reduce((prev, curr) => {
    var previousValue = prev;
    return "".concat(previousValue += curr.split(/(?=[A-Z])/).join('-').toLowerCase(), ":").concat(value[curr], ";");
  }, '');
  return styleString;
};

var distributeProperties = (properties, componentClass) => {
  // initialize
  var attrs = {};
  var props = {};
  var map; // iterate over all properties

  Object.keys(properties).forEach(name => {
    var value = properties[name]; // classify property by type to select correct map object
    // (note that unregistered properties are classified as attr(ibute)s via their undefined .type)

    var type;
    var declaredProperty = componentClass.properties[name] || {};
    var {
      type: declaredType
    } = declaredProperty;
    var looksLikeAnEventHandler = name.indexOf('on') === 0 && // starts with on...
    name.charAt(2) === name.charAt(2).toUpperCase(); // continues with uppercase-letter, i.e. camelCase

    if (looksLikeAnEventHandler) {
      type = Function;
    } else if (name === 'className') {
      type = 'className';
    } else {
      type = declaredType;
    }

    switch (type) {
      case 'className':
      case Array:
      case Object:
      case Function:
      case Boolean:
        map = props;
        break;

      default:
        map = declaredType ? props : attrs;
    } // map property name to value *unless* value is undefined


    if (value !== undefined) {
      if (name === 'style') {
        map[name] = transformStylesObjectToString(value);
      } else {
        map[name] = value;
      }
    }
  });
  return {
    attrs,
    props
  };
};

var withReact = ((createElement, componentClass, version) => {
  var {
    tagName
  } = componentClass;
  var finalTagName = version ? defineVersioned([componentClass], version) : tagName;
  var displayName = pascalCase(finalTagName);

  var reactStatelessComponent = _ref2 => {
    var {
      children
    } = _ref2,
        properties = _objectWithoutProperties(_ref2, _excluded);

    var {
      attrs,
      props
    } = distributeProperties(properties, componentClass);
    return val(createElement)(finalTagName, _objectSpread2({
      isReact: true,
      attrs
    }, props), children);
  }; // displayName is important for React testing (e.g. enzyme) and Chrome DevTools plugins


  reactStatelessComponent.displayName = displayName;
  return reactStatelessComponent;
});

var fireCustomEvent = (function (eventName, detail, target) {
  var {
    bubbles = true,
    composed = true
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // note: the spec(https://dom.spec.whatwg.org/#dom-customevent-customevent),
  // allows 'eventName' to be an existing native event name (e.g. 'change'), which
  // is thereby endowed with the ability to carry custom data (in 'detail')
  var event = new CustomEvent(eventName, {
    detail,
    bubbles,
    composed
  });
  target.dispatchEvent(event);
  return event;
});

var styles = ".o-modal {\n  display: none;\n  width: 100%;\n  height: 100%;\n  position: fixed;\n  z-index: 3000;\n  left: 0;\n  top: 0;\n}\n@media (min-width: 36em) {\n  .o-modal {\n    align-items: center;\n  }\n}\n.o-modal--open {\n  display: flex;\n  justify-content: flex-end;\n  flex-flow: column;\n  -webkit-animation: fade 300ms cubic-bezier(0, 0, 0.2, 1) 1 forwards;\n          animation: fade 300ms cubic-bezier(0, 0, 0.2, 1) 1 forwards;\n}\n@-webkit-keyframes fade {\n  0% {\n    background-color: rgba(0, 0, 0, 0);\n  }\n  100% {\n    background-color: rgba(0, 0, 0, 0.5);\n  }\n}\n@keyframes fade {\n  0% {\n    background-color: rgba(0, 0, 0, 0);\n  }\n  100% {\n    background-color: rgba(0, 0, 0, 0.5);\n  }\n}\n@media (min-width: 36em) {\n  .o-modal--open {\n    justify-content: center;\n  }\n}\n.o-modal__container {\n  display: flex;\n  justify-content: flex-end;\n  flex-flow: column;\n  max-height: 100vh;\n  width: 100%;\n  -webkit-animation: slide-in 300ms cubic-bezier(0, 0, 0.2, 1) 1 forwards;\n          animation: slide-in 300ms cubic-bezier(0, 0, 0.2, 1) 1 forwards;\n}\n@-webkit-keyframes slide-in {\n  0% {\n    transform: translateY(100vh);\n  }\n  100% {\n    transform: translateY(0%);\n  }\n}\n@keyframes slide-in {\n  0% {\n    transform: translateY(100vh);\n  }\n  100% {\n    transform: translateY(0%);\n  }\n}\n@media (min-width: 36em) {\n  .o-modal__container {\n    max-height: none;\n    max-width: 780px;\n    margin: 0;\n  }\n}\n@media (min-width: 36em) {\n  .o-modal__container--small {\n    max-width: 500px;\n    margin: 0;\n  }\n}\n.o-modal__upper-close-container {\n  display: flex;\n  justify-content: flex-end;\n  position: relative;\n  min-height: 56px;\n  margin: 8px 8px 0;\n  box-shadow: 0px 1px 8px rgba(0, 0, 0, 0.15);\n  border-radius: 8px 8px 0 0;\n  background-color: #fff;\n}\n@media (min-width: 36em) {\n  .o-modal__upper-close-container {\n    height: auto;\n  }\n}\n.o-modal__upper-close-container--forced {\n  display: none;\n}\n.o-modal__upper-close-container-button {\n  cursor: pointer;\n  border: none;\n  background: transparent;\n  outline: none;\n  color: inherit;\n  font: inherit;\n  line-height: normal;\n  margin: 8px;\n  height: 40px;\n  padding: 8px;\n}\n.o-modal__upper-close-container-button svg {\n  color: #00008f;\n  height: 24px;\n  width: 24px;\n}\n.o-modal__content {\n  max-height: 100%;\n  overflow: auto;\n  padding: 0 28px 28px;\n  margin: 0 8px 8px;\n  background-color: #fff;\n  border-radius: 0 0 8px 8px;\n  box-shadow: 0px 1px 20px rgba(0, 0, 0, 0.15);\n}\n@media (min-width: 36em) {\n  .o-modal__content {\n    max-height: 70vh;\n  }\n}\n.o-modal__content--forced {\n  border-radius: 8px;\n  padding: 28px;\n  margin-top: 8px;\n}\n@media (min-width: 36em) {\n  .o-modal__content--forced {\n    padding: 40px;\n  }\n}\n.o-modal__close {\n  display: flex;\n  justify-content: flex-end;\n  flex-flow: column;\n}\n.o-modal__close--background {\n  -webkit-animation: fadeOut 200ms cubic-bezier(0.4, 0, 1, 1);\n          animation: fadeOut 200ms cubic-bezier(0.4, 0, 1, 1);\n}\n@-webkit-keyframes fadeOut {\n  0% {\n    background-color: rgba(0, 0, 0, 0.5);\n  }\n  100% {\n    background-color: transparent;\n  }\n}\n@keyframes fadeOut {\n  0% {\n    background-color: rgba(0, 0, 0, 0.5);\n  }\n  100% {\n    background-color: transparent;\n  }\n}\n.o-modal__close--container {\n  -webkit-animation: close 200ms cubic-bezier(0.4, 0, 1, 1);\n          animation: close 200ms cubic-bezier(0.4, 0, 1, 1);\n}\n@-webkit-keyframes close {\n  0% {\n    transform: translateY(0);\n  }\n  100% {\n    transform: translateY(100vh);\n  }\n}\n@keyframes close {\n  0% {\n    transform: translateY(0);\n  }\n  100% {\n    transform: translateY(100vh);\n  }\n}";

/* base class for non-ShadowDom components */
// map: customElementTagName |-> (ownerDocument |-> {referenceCount,style})

var crossTagReferenceCounts = {}; // BASE CLASS

class InlineStyles extends LitElement {
  /* append inline styles iff first instance in current document/ShadowRoot */
  inlineStyles() {
    var staticProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'styles';
    // get this node's document or ShadowRoot, to be used as map key to attach
    // reference-count metadata to
    // N.B. getRootNode needs polyfill for non-Chromium Edge / IE
    // (https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode)
    var root = this.getRootNode(); // retrieve all reference counts by tag name, initializing as needed
    // with WeakMap(). WeakMap (supported by IE11) acts as defense-in-depth
    // against memory leaks if disconnectedCallback is never called
    // (allowed by the spec).

    var referenceCounts = crossTagReferenceCounts[this.tagName] || new WeakMap(); // one more reference, caused by this instance

    var info = referenceCounts.get(root) || {};
    var referenceCount = (info.referenceCount || 0) + 1;
    info.referenceCount = referenceCount; // persist reference-count metadata

    referenceCounts.set(root, referenceCount);
    crossTagReferenceCounts[this.tagName] = referenceCounts; // no style sheet attached sofar?

    if (referenceCount === 1) {
      // remember our root in the instance, if not available natively
      // (ownerDocument), for DOM-removal-time cleanup.
      if (this.ownerDocument !== root) {
        this._rootNode = root;
      } // provision inline style sheet with *string* content
      // from the class property 'styles'


      var style = document.createElement('style');
      var cssAsString = this.constructor[staticProps]; // version the CSS rule selectors, if component
      // does not bear its generic name

      var versionedComponentName = this.nodeName.toLowerCase(); // e.g. axa-datepicker-7-0-2

      var genericComponentName = this.constructor.tagName; // e.g. axa-datepicker

      if (versionedComponentName !== genericComponentName) {
        // in non-ShadowDOM components, the leftmost rule-selector item
        // is the component name itself, serving as a poor-man's rule scoping construct.
        // E.g. datepicker rules are assumed to look like this:
        // axa-datepicker .class1 .... classN { ... }
        cssAsString = cssAsString.split(genericComponentName).join(versionedComponentName); // now, after the above string-to-string transformation they look like this:
        // axa-datepicker-7-0-2 .class1 .... classN { ... }
      }

      style.textContent = cssAsString;
      style.dataset.name = this.tagName.toLowerCase(); // for testing/debugging purposes
      // append it at the right place, *outside* of this instance's children
      // eslint-disable-next-line no-undef

      var parent = root instanceof ShadowRoot ? root : document.head;
      parent.appendChild(style);
      info.style = style;
    } // persist reference-count metadata


    referenceCounts.set(root, info);
    crossTagReferenceCounts[this.tagName] = referenceCounts;
  }
  /* DOM-removal cleanup in module globals */


  disconnectedCallback() {
    super.disconnectedCallback(); // if applicable, prepare reference-count metadata

    var referenceCounts = crossTagReferenceCounts[this.tagName];

    if (!referenceCounts) {
      return;
    }

    var root = this._rootNode || this.ownerDocument;
    var info = referenceCounts.get(root) || {};
    var referenceCount = (info.referenceCount || 0) - 1; // remove or update reference-count metadata

    if (referenceCount < 1) {
      referenceCounts.delete(root); // give an early hint to GC

      var {
        style
      } = info;

      if (style && style.parentNode) {
        style.parentNode.removeChild(style); // remove style node as well
      }
    } else {
      info.referenceCount = referenceCount;
      referenceCounts.set(root, info);
    }
  }

}

var childStyles = "axa-modal[forced] > *:first-child {\n  margin-top: 0 !important;\n}\naxa-modal[forced] > *:last-child {\n  margin-bottom: 0 !important;\n}";

var _templateObject, _templateObject2, _templateObject3;

class AXAModal extends InlineStyles {
  static get tagName() {
    return 'axa-modal';
  }

  static get styles() {
    return css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      ", "\n    "])), unsafeCSS(styles));
  }

  static get properties() {
    return {
      open: {
        type: Boolean
      },
      forced: {
        type: Boolean
      },
      small: {
        type: Boolean
      },
      onClose: {
        type: Function,
        attribute: false
      }
    };
  }

  static get resetHeadingCss() {
    return childStyles;
  }

  constructor() {
    super();
    applyDefaults(this);
  }

  render() {
    return html(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      <article class=\"o-modal ", "\">\n        <div\n          class=\"o-modal__container ", "\"\n        >\n          ", "\n          <div\n            class=\"o-modal__content ", "\"\n          >\n            <slot></slot>\n          </div>\n        </div>\n      </article>\n    "])), this.open ? 'o-modal--open' : '', this.small ? 'o-modal__container--small' : '', !this.forced ? html(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n                <div\n                  class=\"o-modal__upper-close-container ", "\"\n                >\n                  <button\n                    class=\"o-modal__upper-close-container-button\"\n                    @click=\"", "\"\n                  >\n                    ", "\n                  </button>\n                </div>\n              "])), this.forced ? 'o-modal__upper-close-container--forced' : '', this.closeModal, svg([closeIcon])) : '', this.forced ? 'o-modal__content--forced' : '');
  }

  closeModal() {
    var container = this.shadowRoot.querySelector('article > div').classList;
    var article = this.shadowRoot.querySelector('article').classList;
    container.add('o-modal__close--container');
    article.add('o-modal__close--background');
    setTimeout(() => {
      container.remove('o-modal__close--container');
      article.remove('o-modal__close--background');
      this.removeAttribute('open');
    }, 200);
    this.onClose(fireCustomEvent('axa-close', null, this));
  }

  firstUpdated() {
    this.inlineStyles('resetHeadingCss'); // add eventListener to close modal when pressing outside the modal

    document.body.addEventListener('click', ev => {
      this.mouseCloseHandler(ev);
    }); // add eventListener to close modal when pressing esc

    window.addEventListener('keydown', ev => {
      this.keyboardEscapeCloseHandler(ev);
    });
  }

  mouseCloseHandler(e) {
    var _e$composedPath;

    if (!this.forced && ((_e$composedPath = e.composedPath()) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath[0]) === this.shadowRoot.querySelector('.o-modal--open')) {
      this.closeModal();
    }
  }

  keyboardEscapeCloseHandler(e) {
    if (!this.forced && (e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27)) {
      this.closeModal();
    }
  }

  disconnectedCallback() {
    document.body.removeEventListener('click', this.handleWindowKeyDown);
    window.removeEventListener('keydown', this.keyboardEscapeCloseHandler);
  }

}

defineVersioned([AXAModal], {
  "axa-modal": {
    "axa-modal": "2.1.0"
  }
});

var index_react = ((createElement, version) => withReact(createElement, AXAModal, version));

export default index_react;
